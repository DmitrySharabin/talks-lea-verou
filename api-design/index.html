<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<title>API Design is UI Design</title>
	<link rel="icon" href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">☑️</text></svg>' />

	<link href="talk.css" rel="stylesheet" />
	<script src="talk.js" type="module"></script>
</head>
<body class="language-js" data-markdown-elements="details.notes, .md, .md-children > *, .md-gc > * > *, md-ggc > * > * > *">

<header id="intro" class="slide dont-resize">
	<h1>
		<span>API Design</span>
		<span class="is">is</span>
		<span>UI Design</span>
	</h1>
	<div class="by">
		By <a href="http://lea.verou.me">Lea Verou</a><br>
		<small>MIT &bull; W3C TAG &bull; CSS WG &bull; TC39</small>
	</div>
</header>

<article class="slide" id="pain">
	<h1>Ever used an API<span class="asterisk">*</span> that caused you <mark>pain</mark>?</h1>
	<p class="footnote"><span class="asterisk">*</span> Library, framework, component, built-in JS class or function, HTML element, CSS property, etc.</p>
	<details class="notes">
		Raise your hand if you’ve ever used an API that caused you pain.
		This includes libraries, frameworks, components, built-in JS APIs, HTML elements, CSS rules and properties etc.

		Nothing worked in the way you’d expect so you had to look up documentation all the time,
		everything you tried produced errors, and you had to write a ton of boilerplate.
		Seems familiar?
	</details>
</article>

<article class="slide language-markup dont-resize" id="svg-dom">
	<div class="frame-by-frame">
		<img src="images/svg-0.png" alt="">
		<img src="images/svg-1.png" alt="" class="delayed">
		<img src="images/svg-2.png" alt="" class="delayed">
		<img src="images/svg-3.png" alt="" class="delayed">
		<img src="images/svg-4.png" alt="" class="delayed">
		<img src="images/svg-5.png" alt="" class="delayed">
		<img src="images/svg-6.png" alt="" class="delayed">
		<img src="images/svg-7.png" alt="" class="delayed">
	</div>
	<details class="notes">
		Here’s one of mine, the SVG DOM.
		Who here has used the SVG DOM?
		Lucky you!
		You think the HTML DOM is annoying? You haven’t seen anything yet.
		Here’s the simplest SVG ever: just a circle.
		We want to read its radius.

		It starts all innocuous, just a good ol’ `document.querySelector()` to get a reference to an SVG element.
		But it’s downhill from that.

		None of it is _difficult_, but it’s hella _annoying_.
	</details>
</article>

<article class="slide" id="alan-kay">
	<blockquote>
		“Simple things should be easy, complex things should be possible”
		<div class="cite"><a href="https://en.wikipedia.org/wiki/Alan_Kay">Alan Kay</a> (famous computer scientist)</div>
	</blockquote>
	<img src="images/alan-kay.jpg" alt="Portrait of Alan Kay">
	<details class="notes">
		Alan kay said [read] and it’s considered one of the biggest truths in API design.
		But it doesn’t _just_ apply to API design, it’s built-in to almost every (well designed) product we use.
	</details>
</article>

<article class="slide" id="google-calendar">
	<video src="../jsux/img/google-calendar.mp4" muted autoplay loop></video>
	<details class="notes">
		Take Google Calendar as an example. It takes one click to add an event, and we can drag to change its duration or move it to another date or time.

		Indeed, you will find that most usability principles apply to API design, and vice versa.
		APIs are just a different kind of user interface, one that is used by developers instead of end users.
	</details>
</article>

<article class="slide" id="dx">
	<div class="dictionary-dfn">
		<header>
			<h1>
				DX
			</h1>
			<p>
				<span class="ipa">ˈdiː ˈɛks</span>
				<span class="pos">noun</span>
			</p>
		</header>
		<ol>
			<li>Initialism of <em>“Developer Experience”</em>.
				Basically User Experience (UX) when the user is a developer and the interaction involves writing code.</li>
		</ol>
	</div>
	<details class="notes">
		This seemed like such a difficult concept for many, that recently there has been a push to invent a new term
		that basically means "UX when the interaction involves writing code."
	</details>
</article>

<article class="slide">
	<object data="images/curve-alankay.svg"></object>
	<details class="notes">
		Now imagine a plane with two axes: one is the complexity of the use case, i.e. the task users want to do,
		and the other is the complexity of the UI or API that they need to use to do it.

		Alan Kay’s maxim can be visualized as two points on that plane.
		Simple things being easy means there should be a point on the lower left (low use case complexity should result in low UI/API complexity).
		Complex things being possible means there should be a point somewhere on the far end. The lower down the better, but it’s ok even if it has to be higher up.
	</details>
</article>

<article class="slide" id="use-case">
	<div class="dictionary-dfn">
		<header>
			<h1>
				use case
			</h1>
			<p>
				<span class="ipa">juːs keɪs</span>
				<span class="pos">noun</span>
			</p>
		</header>
		<ol>
			<li>A possible, expected, desired use of an interface</li>
			<!-- <li>A description of the different ways a user can interact with an application or product.</li> -->
		</ol>
	</div>
	<details class="notes">
		A use case describes a task that users may want to do with an interface.

		Being aware of user needs is crucial in designing a good UI.
		It means we can solve actual problems that real people have, rather than imagined problems that we think they have.

		Being aware of both the span of use cases that people have and the prominence of each is _crucial_ in designing a good UI.
		Not all use cases are equal: the more common a use case is, the more important it is to optimize for.
	</details>
</article>

<article class="slide dont-resize" id="use-case-examples">
	<header>
		<h1>How will <mark>people</mark> use it?</h1>
		<p class="subtitle">Pain points, Use cases, usage scenarios, user goals</p>
	</header>
	<ul class="delayed">
		<li class="delayed">Assemble IKEA cabinet</li>
		<li></li>
		<li>
			<img src="images/screwdriver.jpg" alt="">
		</li>
		<li></li>
		<li class="delayed">Screw a drywall screw</li>
	</ul>
	<object data="images/high-low-level.svg" type=""></object>
	<details class="notes">
		There are many different words to describe user needs: pain points, use cases, usage scenarios, user goals.
		The distinction not particularly useful here, and they are not even used consistently in the wild.
		What matters is to do the research and understand what people want to do with your API, not what to call it.

		So for simplicity we’ll just stick to one: _“use case”_, which can be either high level, low level, or anywhere in between.

		For example, a high level use case for a screwdriver could be to assemble an IKEA cabinet,
		and a low level use case to screw in a drywall screw.
	</details>
</article>

<article class="slide dont-resize" id="use-case-examples">
	<header>
		<h1>How will <mark>people</mark> use it?</h1>
		<p class="subtitle">Pain points, Use cases, usage scenarios, user goals</p>
	</header>
	<ul>
		<li class="delayed">Validate a postcode</li>
		<li></li>
		<li><h2>Regular Expressions</h2></li>
		<li></li>
		<li class="delayed">Match repeating digits</li>
	</ul>
	<object data="images/high-low-level.svg" type=""></object>
	<details class="notes">
		Similarly, APIs also have use cases.
		For example, a high level use case for regular expressions could be data validation,
		and a low level use case to match repeating digits.
	</details>
</article>

<article class="slide">
	<object data="images/curve-svgdom.svg"></object>
	<details class="notes">
		Now let’s get back to the _use case complexity_ to _UI complexity_ chart.
		Where would the SVG DOM be on that plane?

		I think it would be a flat line: all the complexity of the edge cases is in your face at all times.
		You have to deal with base values and units even when all you want is a damn number.

		Ideally, complexity should be progressively revealed: there when you need it, tucked away when you don’t.
	</details>
</article>

<article class="slide language-html columns force-3" id="select">

	<section>
		<pre><code>
			&lt;select id="country">
				&lt;option value="fr" selected>
					France
				&lt;/option>
				&lt;option value="gr">
					Greece
				&lt;/option>
				&lt;option value="us">
					United States
				&lt;/option>
			&lt;/select>
		</code></pre>
		<video src="videos/select.mp4" muted autoplay loop></video>
	</section>
	<section class="delayed">
		<pre><code>
			&lt;select id="country" multiple>
				&lt;option value="fr" selected>
					France
				&lt;/option>
				&lt;option value="gr">
					Greece
				&lt;/option>
				&lt;option value="us">
					United States
				&lt;/option>
			&lt;/select>
		</code></pre>
		<video src="videos/select-multiple.mp4" muted autoplay loop></video>
	</section>
	<section class="delayed">
		<h2>???</h2>
		<img src="images/multiselect.png" alt="">
	</section>

	<details class="notes">
		Let’s look at another example, a humble `&lt;select>` menu.
		Are HTML elements APIs? Of course. Just like your own components.

		Several issues with this API.
		First, you can add a `multiple` attribute and turn it into a multiselect listbox, but what if you wanted a multiselect dropdown?
		This highlights a very common antipattern, which is best explained with an example from UI design in the physical world.

		----

		Now back to the `&lt;select>` element.
		Lack of orthogonality is not its only issue.

		It’s certainly quite simple to use! But, it doesn’t do very much.
		You can use JS to manipulate the options dynamically, but that’s about it.
	</details>
</article>

<article class="recap tip slide">
	<h1>Orthogonal knobs for orthogonal concepts</h1>
	<div class="columns force-2 full-height">
		<img src="images/faucet-1.jpg" alt="">
		<img src="images/faucet-2.jpg" alt="">
	</div>
	<details class="notes">
		Remember these older faucets with a separate control for hot and cold water?
		This is a great example of UI design being driven by implementation specifics, rather than user needs.
		The use cases are clear: 1. adjust the flow of water, and 2. adjust the temperature of water.
		The implementation involves adjusting the flow of two streams of water: one for hot water and one for cold water.
		The older faucets were simply exposing these internals to users, causing a lot of frustration because it was impossible to adjust temperature without also adjusting flow,
		so every change requires a series of adjustments and corrections.
		This was fixed with the newer mixer faucets which expose the two concepts separately.
	</details>
</article>

<article class="slide" data-insert="#select">
</article>

<article class="slide columns force-3" style="grid-template-columns: 3fr 1.2fr 2.5fr">
	<img src="images/airbnb-select.png" alt="">
	<img src="images/selectlist-animation.gif" alt="">
	<img src="images/multiselect.png" alt="">

	<details class="notes">
		You can’t style it or add custom content, you can’t add a search box, you can’t allow custom options, you can’t turn it into a multiselect
		or combo box.
		It has the opposite problem: simple things are easy, but complex things are _not_ possible.

		No wonder it comes up as a top pain point in most web development surveys
		and is the most frequently recreated HTML element.
	</details>
</article>

<article class="slide">
	<object data="images/curve-svgdom-select.svg"></object>

	<details class="notes">
		Let’s add `&lt;select>` to our chart.
		Note that it starts at the bottom left, which is good, but then just …stops.

		Thankfully, there are recent efforts to extend `&lt;select>` to cater to all these use cases, but until then it remains an excellent example
		of an API that makes simple things easy, but complex things impossible.
	</details>
</article>

<!-- <article class="slide columns force-2">
	<h1>How?</h1>

	<section>
		<h2>Making simple things easy</h2>

		<ul>
			<li>Sensible defaults</li>
			<li>Shortcuts</li>
			<li>Consistency</li>
			<li>Robustness</li>
		</ul>
	</section>
	<section>
		<h2>Making complex things possible</h2>

		<ul>
			<li>Extension points</li>
			<li>Composability</li>
			<li>Aggregation</li>
		</ul>
	</section>
</article> -->

<article class="slide language-markup" id="video-controls" id="video-simple">
	<pre><code>&lt;video src="videos/cat.mp4" controls>&lt;/video></code></pre>
	<video src="videos/cat.mp4" controls></video>
	<details class="notes">
		Now let’s look at another example, the `&lt;video>` element and its corresponding JS API,
		and specifically its playback controls.
		Simple things are certainly easy: all we need to do to get a nice default toolbar is add the `controls` attribute.
	</details>
</article>

<article class="slide" id="video-complex">
	<img src="images/youtube.png" alt="">
	<img src="images/netflix.png" alt="" class="delayed">

	<details class="notes">
		Now let’s suppose use case complexity increases just a tiny bit.

		Maybe I want to add a selector for closed captions.
		Or a button to open the video on YouTube.
		Or indicators about key moments in the video.

		Or maybe buttons to jump 10 seconds back or forwards.
		Or an episode selector.

		None of these were particularly niche, but the default controls are all-or-nothing:
		even if all we need is to add a single button, we have to reimplement everything from scratch.
	</details>
</article>

<article class="slide language-markup dont-resize" id="video-no-controls">
	<pre><code>&lt;video src="videos/cat.mp4">&lt;/video></code></pre>
	<div class="columns code-labels count-lines delayed-children">
		<pre class="language-js"><code>
			let controls = Object.assign(document.createElement('div'), {
				className: 'video-player'
			});
			video.replaceWith(controls);
			controls.append(video);
			controls.insertAdjacentHTML('beforeend', `&lt;div class="video-controls">
				&lt;div class="toolbar">
					&lt;button class="play-pause" title="Play">&lt;i class="fa-play">&lt;/i>&lt;/button>
					&lt;button class="jump-back">&lt;i class="fa-arrow-rotate-left">&lt;/i>&lt;/button>
					&lt;button class="jump-forward">&lt;i class="fa-arrow-rotate-right">&lt;/i>&lt;/button>
					&lt;input type="range" class="volume" max="1" step="0.01" value="1">
					&lt;button id="fullscreen">&lt;i class="fa-expand">&lt;/i>&lt;/button>
				&lt;/div>
				&lt;input type="range" class="progress" step="0.1" value="0">
			&lt;/div>`);

			controls.querySelector(".play-pause").addEventListener('click', async function () {
				if (video.paused) {
					await video.play();
					this.title = 'Pause';
					this.firstElementChild.className = "fa-pause";
				}
				else {
					video.pause();
					this.title = 'Play';
					this.firstElementChild.className = "fa-play";
				}
			});
			controls.querySelector('.jump-back').addEventListener('click', function() {
				video.currentTime -= 10;
			});
			controls.querySelector('.jump-forward').addEventListener('click', function() {
				video.currentTime += 10;
			});
			controls.querySelector('.progress').addEventListener('input', function() {
				video.currentTime = this.value / 100 * video.duration;
			});
			controls.querySelector('.volume').addEventListener('input', function() {
				video.volume = this.value;
			});

			video.addEventListener('timeupdate', function() {
				controls.querySelector('.progress').value = this.currentTime / this.duration * 100;
			});
		</code></pre>
		<pre class="language-css"><code>
			.video-player {
				position: relative;

				.video-controls {
					position: absolute;
					bottom: 0;
					left: 0;
					right: 0;
					padding: .4em .5em;
					display: flex;
					flex-flow: column;
					background-color: rgb(0 0 0 / 20%);
					backdrop-color: blur(5px);

					.toolbar {
						display: flex;
						justify-content: space-between;

						.volume {
							width: 30%;
						}

						button {
							cursor: pointer;
							background-color: #444;
							border: none;
							color: white;
							padding: 5px 10px;
						}
					}

					.progress {
						width: 100%;
					}
				}
			}
		</code></pre>
	</div>


	<details class="notes">
		Just reimplementing the simplest toolbar takes us from 1 loc to …81!
		And in practice a lot more.
		Yes, there are libraries and components for this.
		But designing APIs excpecting people to use libraries for primary use cases is never a good idea.
	</details>
</article>

<article class="slide">
	<object data="images/curve-cliff.svg"></object>

	<details class="notes">
		This is called a **usability cliff**: a point where a small increase in use case complexity results in a huge increase in UI complexity.
		We see these cliffs frequently in UIs that make simple things easy and complex things possible by providing two completely distinct interfaces:
		a super high level one that caters to the simplest use cases very easily,
		and a super low level one that lets us do whatever but we have to reimplement _everything_ from scratch.
	</details>
</article>

<article class="slide" id="delightful-apis">
	<header>
		<h1>Delightful APIs</h1>
		<p class="subtitle">Incremental user effort produces incremental value</p>
	</header>
	<object data="images/curve-delightful-3.svg#paused"></object>
	<details class="notes">
		Making simple things easy and complex things possible is a good first step, and it’s surprising how many APIs fail it.
		But these are just the two ends of the spectrum.
		For truly delightful APIs all the points in between matter as well.
	</details>
</article>

<article class="slide" id="delightful-apis-2">
	<header>
		<h1>Delightful APIs</h1>
		<p class="subtitle">Incremental user effort produces incremental value</p>
	</header>
	<object data="images/curve-delightful-3.svg"></object>
	<details class="notes">
		You want to be aiming for a smooth curve, where the complexity of the API increases gradually as the complexity of the use case increases.
		In fact, the more gradual the increase the better.
	</details>
</article>



<!-- <article class="slide">
	<h1>Which one is better?</h1>
	<object data="images/curve-floor-ceiling.svg"></object>
	<details class="notes">
		There are many ways to have a smooth ease-of-use to power curve.
		If we compare two APIs, A and B, which do you think has better usability?
		Both have a relatively smooth ease-of-use to power curve, so they’re probably not too bad.
		A has a _higher ceiling_, meaning you can do more things.
		B has a lower ceiling, but also a _lower floor_, meaning it’s easier to get started with.
		Furthermore, B’s UI complexity remains lower for pretty much all use cases.
		So which one is better?
		We can’t tell without knowing anything about them.
		How important are the use cases you can’t do with B? How commonly do they come up?
	</details>
</article> -->
<article class="slide columns force-2">
	<header>
		<h1>Which one is better?</h1>
		<p class="subtitle delayed" data-index="2">Optimize for the right use cases</p>
	</header>
	<object data="images/curve-ab.svg"></object>
	<ul class="examples delayed" data-index="1">
		<li class="bad"><strong style="color: #15aabf">A</strong>
			<pre><code>
				!!(a.compareDocumentPosition(b)
				   & Node.DOCUMENT_POSITION_CONTAINS)
			</code></pre>
		</li>
		<li class="good"><strong style="color: #2f9e44">B</strong>
			<span class="delayed" data-index="3">✅</span>
			<pre><code>a.contains(b)</code></pre>
		</li>
	</ul>
	<details class="notes">
		Take a look at these two APIs.

		Which one is better?
		A can do more, but is more complex even for simple things.
		B can only do one thing, but it does it well.

		We can’t tell without knowing anything about them.
		How important are the use cases you can’t do with B? How commonly do they come up?

		Remember `compareDocumentPosition()`? So many issues with this API.
		It returns a bitmask, making simple things weird.
		But the complex case it was trying to solve is largely imaginary, or at least very niche.
		It’s far, _far_ more common to need to check if an element contains another than to compare source order.
		So `contains()` is the clear winner here, even if it can’t do as much.
	</details>
</article>

<article class="slide" id="priority-of-constituencies" data-steps="2">
	<header>
		<h1>Drive complexity inwards</h1>
		<p class="subtitle">“Put the pain on those who can bear it”</p>
	</header>

	<blockquote>
		<div><strong>User needs</strong></div>
		<div>come before the needs of <strong>web page authors</strong></div>
		<div>which come before the needs of <strong>user agent implementors</strong></div>
		<div>which come before the needs of <strong>specification writers</strong></div>
		<div>which come before <strong>theoretical purity</strong></div>
		<div class="cite"><a href="https://w3.org/TR/design-principles/#priority-of-constituencies">1.1. Put user needs first (Priority of Constituencies)</a><br>
			<a href="https://w3.org/TR/design-principles/">Web Platform Design Principles</a></div>
	</blockquote>

	<details class="notes">
		“Simple” in Kay’s maxim refers to the conceptual complexity of the use case, not the implementation.
		Simple things are the most common things that people want to do with your API, not things that are necessarily simple to implement.

		Remember the faucet example: the older faucets were simpler to implement, but made the most common user goals hard.
		The newer faucets are a little more complex to implement internally, but make the primary use cases simple.

		This is not a coincidence. It’s a good rule of thumb to opt for internal complexity over external complexity.

		In the web standards world, it’s known as the **Priority of Constituencies**,
		which goes like this: [read out]

		For example, being someone designing APIs for the Web Platform, _your_ needs are above _my_ needs.
		The different groups may vary, but the core idea is the same and applies to all product and API design.
		What this tells us is to prioritize users over implementors, and to be pragmatic.

		Encapsulating complexity in the lowest level possible centralizes and abstracts it away,
		which minimizes collective pain since most UIs have a lot more users than implementors.
		If your API has fewer users than implementors, by all means, ignore this!

		Another reason to do this is that if your abstractions are doing their job,
		users will need less technical knowledge than implementors,
		which brings us to another formulation of this principle: "put the pain on those who can bear it".
	</details>
</article>

<article class="tip recap slide" id="internal-over-external">
	<h1>Encapsulate complexity</h1>

	<div>
		<pre><code>
			const sanitizer = new Sanitizer(<span class="delayed collapse">{
				allowElements: ['span', 'em', 'strong', 'b', 'i'],
				allowAttributes: {'class': ['*']},
			}</span>);
			let nodes = sanitizer.sanitize(untrusted_input);
			container.replaceChildren(nodes);
		</code></pre>
	</div>

	<details class="notes">
		Even though it was removed for other reasons,
		this was something the [Sanitizer API](https://developer.mozilla.org/en-US/docs/Web/API/HTML_Sanitizer_API) proposal did _really_ well.
		It’s a great example that the most common use cases are not necessarily the simplest conceptually, or the simplest to implement,
		but they’re the ones to optimize for.

		In an HTML sanitizer, the common case is that we want to take untrusted input and make it it self to stuff into `innerHTML`.
		This does not involve simply an allowlist of elements and attributes, but is actually pretty complex.

		It would be far simpler for implementation if users had to provide inputs for what to allow,
		but that would make the common case tedious AF.

		Instead, this API used an excellent design: it optimized for the common case by having sensible defaults,
		and provides extension points that allowed users to override the defaults when they need to.

		UI complexity was revealed progressively, as needed, and did not get in the way when not needed. Perfect! 👌🏼
	</details>
</article>

<article class="tip recap slide">
	<header>
		<h1>
			No boilerplate
		</h1>
		<p class="subtitle">Syntax should not require more than is needed to declare intent</p>
	</header>

	<ul class="examples">
		<li class="bad">
			<pre><code>parent.removeChild(node);</code></pre>
		</li>
		<li class="good">
			<pre><code>node.remove();</code></pre>
		</li>
	</ul>

	<details class="notes">
		If it can be inferred, it’s your API’s job.

		Remember the older DOM methods like `removeChild()`? Every operation required a reference to the parent.
		But the parent could be inferred from the node!
		There was absolutely no reason for this, except some vague academic ideas about theoretical purity,
		which as we’ve just seen, should be at the very bottom of priorities.

		Users should not have to copy and paste (or these days, generate with AI) boilerplate and have to manage multiple sources of truth for the same thing.
		What is the minimum syntax needed to clearly and unambiguously declare their intent?
		Can you make that syntax possible?
	</details>
</article>

<article class="slide">
	<header>
		<h1>Layering</h1>
		<p class="subtitle">No, you don’t have to do it all at once</p>
	</header>
	<img src="images/layers.webp" alt="">
	<details class="notes">
		A smooth use case complexity to UI complexity curve requires a lot more resources than a quick fix.
		But you don’t need to spend all those resources up front and delay shipping.

		It’s common to ship these APIs in layers,
		with each release changing the curve for the better,
		ether making simple things easier, or pushing the boundary of what is possible.

		Sometimes that’s the plan from the start, and sometimes it just works out this way, as a response to developer feedback.

		But where to start from?
		That depends on a number of factors.
		What is the biggest pain point that your API is solving?
		Is it that the status quo is too hard or that things are not possible?
		How diverse are the primary use cases? How well do you understand user needs?
	</details>
</article>

<article class="slide">
	<h1>High level first</h1>
	<object data="images/curve-shipping-hlf.svg" type=""></object>

	<details class="notes">
		If the primary use cases are well-known, and clustered around a few common patterns, and we have a pretty good idea about how to address them,
		we can start with a high level design that covers them well
		and ship extension points and lower level primitives later that explain the high level feature.
		As a rule of thumb, this works well when that high level MVP can cover about 80% of use cases.
	</details>
</article>

<article class="slide">
	<h1>Low level first</h1>
	<object data="images/curve-shipping-llf.svg" type=""></object>

	<details class="notes">
		If you have less confidence about what a high level API could look like,
		or the use cases are too diverse,
		or the biggest pain point is around things not being possible,
		you can start with a lower level primitive that makes complex things possible, even if simple things are hard.

		We can deploy this and learn from the way people use it, then use this knowledge to design a better high level API.

		In general, this tends to be a safer path, as it makes fewer assumptions.
		The wrong high-level API will not be used at all,
		whereas an API that is too low-level will be painful, but still usable,
		and people can always build and share abstractions on top of it.

		One danger with that path is complacency.
		It’s common to ship a low-level API planning to later ship a higher level one and never do so.
		This is easy to happen since users will rarely complain about simple things not being easy — they are far more vocal about things not being possible.
		But their pain is still there. They just tend to blame themselves for it, or resign to it as a part of life and build their own abstractions.
		There is so much poor UX out there that people are _surprised_ when things work well!
	</details>
</article>

<article class="slide" id="dateformat">
	<h1>Layering done right</h1>

	<div class="frame-by-frame full-height">
		<img src="images/date-1.png" alt="">
		<img src="images/date-2.png" alt="" class="delayed">
		<img src="images/date-3.png" alt="" class="delayed">
		<img src="images/date-4.png" alt="" class="delayed">
		<img src="images/date-5.png" alt="" class="delayed">
		<img src="images/date-6.png" alt="" class="delayed">
		<img src="images/date-7.png" alt="" class="delayed">
		<img src="images/date-8.png" alt="" class="delayed">
		<img src="images/date-9.png" alt="" class="delayed">
		<img src="images/date-10.png" alt="" class="delayed">
	</div>

	<details class="notes">
		Here’s an example of high-level first layering that resulted in a very smooth curve eventually.
		For years, all we had was this super high level `toLocaleString()` method on `Date` objects,
		that gave you some formatted datetime in the user’s locale.

		It was so high level it was practically useless.
		But once the `Intl.DateTimeFormat` API came along, it also enhanced the `toLocaleString()` method,
		so that you could get progressively more control over the output format.

		You want to just provide a locale? You can do that and it will deal.
		You want to just provide a hint about how long the date should be? You can do that and it will deal.
		You want to control the format and presence of each individual part of the date? You can do that too.
		You want total control, and just want the API to give you a data structure of all the parts?
		You guessed it, you can do that too.
	</details>
</article>

<article class="slide" id="user-testing" data-credits="youtube.com/watch?v=BrVnBdW6_rE">
	<header>
		<h1>User testing</h1>
		<p class="subtitle">Yes, it works for APIs too.</p>
	</header>

	<video src="videos/user-testing.mp4" muted autoplay loop></video>

	<details class="notes">
		Lastly, let’s talk about a few general usability guidelines and how they apply to API design,
		starting from user testing, the cornerstone of usability.

		You are not the user, and you know too much about your UI.
		Dogfooding is great, but it’s not enough.
		You need to see how people who aren’t you use what you designed.

		User testing is surrounded by many misconceptions.
		One misconception is that it only applies to visual interfaces.

		The core idea is to get ahold of a few representative users (and for an API these will be developers, but not developers of that API),
		ask them to perform a few representative tasks,
		observe what they do, where they succeed, and where they struggle.
		None of this requires visuals.

		For user testing to be valuable, it’s important that you **shut up and let the users the talking**.
		Make it clear upfront that you are testing the design, not them, and that you can answer their questions after, but not during.
		You can give them documentation, and even a brief tutorial in the beginning, but after that, you should not help them,
		only encourage them to think out loud and ask non-leading questions.
	</details>
</article>
<article class="slide" id="user-testing-2" data-credits="Norman/Nielsen Group">
	<header>
		<h1>User testing</h1>
		<p class="subtitle">No, it’s not some big investment.</p>
	</header>

	<img src="images/5-users.jpg" alt="">

	<details class="notes">
		Another misconception is that user testing is time-consuming and expensive.
		Nope, you need no special equipment, it can be done over a Zoom call,
		or live with a screen recorder,
		and [you only need five users](https://www.nngroup.com/articles/why-you-only-need-to-test-with-5-users/)
		to uncover 80% of the problems.
		Even just two users will reveal half of the issues.

		User testing can also be fantastic in resolving these long bikeshedding debates in a team.
		Should we call it this or that? Should we use positional arguments or an object literal?
		Test with both! In most cases, the answer will be clear.
	</details>
</article>

<article class="recap tip slide dont-resize">
	<h1>It’s not the user’s fault</h1>

	<!-- <pre><code>
		import styles from "./styles.css";
	</code></pre> -->
	<figure>
		<img src="images/css-in-js.png" alt="">
		<figcaption>
			CSS-in-JS usage over time,
			State of CSS 2023
		</figcaption>
	</figure>

	<details class="notes">
		If one user makes a mistake using your UI, it could be their fault.
		But if several users are making the same mistake, the problem lies with your UI and you should figure out how to serve their needs better instead of blaming them.

		An example from the web platform is CSS-in-JS.
		It has been a point of contention for at least a decade.
		As one of the people who design CSS, I’m not personally a fan of it.
		But the attitude that developers are _doing it wrong_ and should "simply" learn to use CSS properly is problematic.

		Thankfully, in recent years the attitude has changed and we are shipping a ton of features that should hopefully make CSS-in-JS less necessary.
	</details>
</article>

<article class="slide takeway" id="dogfood">
	<h1>Dogfood, dogfood, dogfood</h1>

	<details class="notes">
		Go make things with your own APIs.
	</details>
</article>

<article class="slide recap tip" id="beginner">
	<h1>Remain a beginner</h1>

	<details class="notes">
		Obviously I’m not suggesting you should stop learning.

		But a lot of poor API design comes from engineers who are _really good_.
		Because they are so great, they have forgotten what it’s like to be a beginner.
		They assume too much. They expect too much.
		They think confusing patterns are “obvious” and “self-explanatory”.

		For every kind of API design, it’s important to hold on to the perspective of a beginner, even once you’re far from one.
		Talk to beginners. Watch them use your API. Do they struggle?
		Which brings us to…
	</details>
</article>

<article class="slide recap tip" data-credits="Chinwe Uzegbu" id="empathy">
	<h1>Hone your <strong>empathy</strong></h1>

	<details class="notes">
		The biggest, most important point is to hone your _empathy_.
		Simply **caring** about users goes a long way, and matters more than any individual design principle.

		Think about the humans that will use the APIs you’re designing.
		Their needs, their use cases. Make their lives easier. Reduce their pain.
	</details>
</article>

<footer class="slide" id="end">

</footer>

</body>
</html>