<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<link rel="dns-prefetch" href="https://lea.verou.me">
	<link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
	<title>A story of 🧊 ice, 🔥 fire, and 🪆 CSS Nesting</title>
	<link rel="icon" href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">🪆</text></svg>' />

	<link href="css/talk.css" rel="stylesheet" />

	<script src="../shared/js/bliss.shy.min.js"></script>
	<script src="../shared/js/prism.js" data-manual></script>
	<!-- <script src="https://incrementable.verou.me/incrementable.js" type="module"></script> -->
	<script src="https://inspirejs.org/inspire.mjs" type="module"></script>
	<script src="talk.js" type="module"></script>
</head>
<body class="language-css no-docs no-media" data-markdown-elements="details.notes, .md, .md-children > *, .they-said blockquote">

<header id="intro" class="slide dont-resize">
	<h1>A story of
		<div>
			<span class="ice">ice</span>,
			<span class="fire">fire</span>
		</div>
		&
		<span class="nesting">CSS <span>N<span>e<span>s<span>t<span>i<span>n<span>g</span></span></span></span></span></span></span></span>
	</h1>
	<p class="attribution">By <a href="http://lea.verou.me">Lea Verou</a> (<a href="http://twitter.com/leaverou">@LeaVerou</a>)</p>
</header>

<section id="background" class="code-labels">
	<article class="slide columns c3" id="css-preprocessors">
		<h1>
			CSS Preprocessors
		</h1>
		<div>
			<time>2006</time>

			<h2>
				<img src="img/sass-logo.svg" alt="Sass">
			</h2>
			<a href="https://sass-lang.com">sass-lang.com</a>
		</div>
		<div class="delayed persistent">
			<time>2009</time>

			<h2>
				<img src="img/less-logo.png" alt="Less">
			</h2>
			<a href="https://lesscss.org/">lesscss.org</a>
		</div>
		<div class="delayed persistent">
			<time>2010</time>

			<h2>
				<img src="img/stylus-logo.svg" alt="Stylus">
			</h2>
			<a href="https://stylus-lang.com/">stylus-lang.com</a>
		</div>
		<details class="notes">
			Our story begins back in the ancient 2006, with the appearance of the first CSS preprocessor that actually became popular.
			It was called Sass, and it was written in Ruby.
			Two more appeared in the following years: Less, written in JavaScript, and Stylus, also written in JavaScript.
			CSS Preprocessors are languages that compile to CSS, allowing easier syntax without it having to be suppprted in browsers.
			There were other preprocessors before Sass, but they didn't really take off.

			A lot changed in the CSS landscape once preprocessors appeared.
		</details>
	</article>

	<article class="slide">
		<h1>Top 3 preprocessor features</h1>

		<ul>
			<li style="list-style: '🥇';">Variables</li>
			<li style="list-style: '🥈';">Calculations</li>
			<li style="list-style: '🥉';">Nesting</li>
		</ul>
		<details class="notes">
			Note that all three features are about reuse: variables and calculations are about value reuse, nesting is selector reuse.
			This is what CSS was desperately lacking: reusability mechanisms to make it more maintainable.
		</details>
	</article>

	<article class="slide columns conversion code-labels" id="sass-variables">
		<h1>Sass Variables</h1>

		<div>
			<pre class="language-scss"><code>
				$color-accent: oklch(50% .3 180);
				$font-sans: Helvetica, sans-serif;

				body {
					font: 100%/1.5 $font-sans;
					accent-color: $color-accent;
				}
			</code></pre>
		</div>
		<div>
			<pre class="language-css delayed"><code>
				body {
					font: 100%/1.5 Helvetica, sans-serif;
					accent-color: oklch(.5 .3 180);
				}
			</code></pre>
		</div>
		<details class="notes">
			Preprocessor variables (like every preprocessor feature)
			are compiled to CSS, which is then sent to the browser.
		</details>
	</article>

	<article class="slide columns">
		<h1>Native CSS Variables</h1>

		<div>
			<pre data-clone="#sass-variables pre.language-scss"></pre>
		</div>
		<div>
			<pre class="language-css delayed"><code>
				:root {
					--font-sans: Helvetica, sans-serif;
					--color-accent: oklch(.5 .3 180);
				}

				body {
					font: 100%/1.5 var(--font-sans);
					accent-color: var(--color-accent);
				}
			</code></pre>
		</div>
		<details class="notes">
			At first glance, the CSS version looks more clumsy and verbose.
			Why not just adopt one of the preprocessor syntaxes?
		</details>
	</article>

	<article class="slide columns" id="reactive-css-variables">
		<h1 class="container">CSS Variable Reactivity</h1>
		<pre><code>
			.container {
				--accent-color: oklch(60% .15 var(--angle, 0deg));
			}
			h1, button { color: var(--accent-color); }
			button {
				border: .1em solid var(--accent-color);
			}
			button.primary, button:hover {
				background: var(--accent-color);
				color: white;
			}
		</code></pre>
		<pre class="delayed"><code>
			@property --angle {
				syntax: "&lt;angle>";
				inherits: true;
				initial-value: 0deg;
			}
			@keyframes angle-spin {
				to { --angle: 1turn; }
			}
			.container {
				animation: angle-spin 4s linear infinite;
			}
		</code></pre>
		<style data-slide>
			button {
				background: transparent border-box;
				border-radius: .2em;
				padding: .15em .6em;
				font-weight: 500;
				letter-spacing: inherit;
			}
		</style>
		<style data-slide data-clone="code"></style>
		<style data-slide data-clone="pre + pre > code"></style>
		<div class="container">
			<button>Log in</button>
			<button class="primary">Sign up</button>
		</div>
		<details class="notes">
			However, if you look more closely, the CSS syntax has several advantages.
			CSS variables are actual CSS properties, and share their reactive nature.

			We can animate them, set them with JS, change them with media queries, and everything automatically adapts.
		</details>
	</article>

	<!-- TODO: Maybe demo to show that MQs can also tweak variables -->

	<article class="conversion slide columns" id="sass-math">
		<h1>Sass Calculations</h1>

		<div>
			<pre class="language-scss"><code>
				$spacing: 16px;

				button {
					padding: $spacing / 2;
				}
			</code></pre>
		</div>
		<div>
			<pre><code>
				button {
					padding: 8px;
				}
			</code></pre>
		</div>
	</article>

	<article class="conversion slide columns" id="sass-math">
		<h1>Sass Calculations</h1>

		<div>
			<pre class="language-scss"><code>
				$spacing: 16px;

				textarea {
					padding: $spacing / 2;
					width: 100% - $spacing;
				}
			</code></pre>
		</div>
		<div>
			<pre class="language-none error"><code>
				Incompatible units: 'px' and '%'.
			</code></pre>
		</div>
	</article>

	<article class="slide columns">
		<header>
			<h1>Native CSS Calculations</h1>
			<p class="subtitle">calc() in 2013</p>
		</header>

		<div>
			<pre data-clone="#sass-math pre.language-scss"></pre>
		</div>
		<div>
			<pre><code>
				:root {
					--spacing: 16px;
				}

				textarea {
					padding: calc(var(--spacing) / 2);
					width: calc(100% - var(--spacing));
				}
			</code></pre>
		</div>
	</article>

	<article class="conversion slide columns compact-code">
		<h1>Sass Color Calculations</h1>

		<pre class="language-scss"><code>
			$color-accent: #037465;

			button {
				background: lighten($color-accent, 20%);
			}
		</code></pre>
		<pre style="flex: none"><code>
			button {
				background: #06d7bc;
			}
		</code></pre>
	</article>

	<article class="conversion slide columns">
		<h1>But…</h1>

		<div>
			<pre class="language-scss"><code>
				$color-accent: oklch(.5 .3 180);

				button {
					background: lighten($color-accent, 20%);
				}
			</code></pre>
		</div>
		<div>
			<pre class="language-none error"><code>
				argument `$color` of `lighten($color, $amount)` must be a color
			</code></pre>
		</div>
	</article>

	<article class="slide">
		<header>
			<h1>CSS Relative Colors</h1>
			<p class="subtitle"><a href="https://caniuse.com/css-relative-colors">Coming soon!</a></p>
		</header>

		<div>
			<pre><code>
				button {
					background: oklch(from var(--color-accent) calc(l * 1.2) c h);
				}
			</code></pre>

			<pre class="delayed"><code>
				button {
					background: oklch(from var(--color-accent) calc(l + .2) c h);
				}
			</code></pre>
		</div>
		<details class="notes">
			You may be starting to see a pattern:
			Once more the native CSS version involves clunkier syntax but is more powerful.
		</details>
	</article>

	<article class="slide" id="preprocessors-vs-css">
		<table>
			<thead>
				<tr>
					<th></th>
					<th>Preprocessors</th>
					<th>CSS</th>
				</tr>
			</thead>
			<tbody class="delayed-children">
				<tr>
					<th>Performance requirements</th>
					<td class="win">Looser</td>
					<td>Stricter</td>
				</tr>
				<tr>
					<th>Syntax restrictions</th>
					<td class="win">Looser</td>
					<td>Stricter</td>
				</tr>
				<tr>
					<th>Iteration speed</th>
					<td class="win">Faster</td>
					<td>Slower</td>
				</tr>
				<tr>
					<th>Context Awareness</th>
					<td>None</td>
					<td class="win">Full</td>
				</tr>
				<tr>
					<th>Reactivity</th>
					<td>None</td>
					<td class="win">Yes</td>
				</tr>
				<tr>
					<th>Implementation Limits</th>
					<td>CSS</td>
					<td class="win">C++</td>
				</tr>
			</tbody>
		</table>
		<details class="notes">
			Preprocessors and native CSS syntax have different strengths and weaknesses.
			- Native CSS syntax is subject to much stricter performance requirements.
			Preprocessors only run once, split out CSS, and are done with it, so anything that runs in speed acceptable for a build tool is fair game.
			CSS doesn't have that luxury. CSS code can be changed and need to re-run millions of times per second, so it has to be blazing fast.
			This means that certain things that are simple for preprocessors are very hard to do in CSS.
			- Native CSS syntax is subject to much stricter syntax restrictions.
			Any syntax added to CSS has to be *both* backwards compatible with existing CSS as well as forwards compatible with any possible future CSS.
			While this is also a concern for preprocessors, things are a bit easier there due to versioning.
			- Preprocessors have much faster iteration speed.
			Adding a new feature requires consensus among the preprocessor maintainers, then it can be implemented and shipped soon after.
			Adding a new feature to CSS requires consensus among the CSS WG, then someone to write the specification, iterate on it, ensure the spec is implementable,
			convince browser vendors to implement it, then wait for it to be implemented, then wait for it to be shipped, then wait for it to be widely adopted.
			The length of this process varies, but it's usually measured in years.
			- However, native CSS syntax has full context awareness.
			It knows what the viewport size is, which media queries apply, what is supported and what isn't, what are the metrics of the font being used, etc.
			This allows native CSS syntax to be a lot more powerful.
			- Native CSS syntax is reactive. If any of its components change, it will update automatically.
			Preprocessor syntax is executed top to bottom, analogously to imperative programming.
			- Lastly, because preprocessor syntax has to be ultimately compiled to CSS, it is subject to the same implementation limits as CSS.
			However, native CSS syntax can *extend* the bounds of what is possible in CSS, and is only bound by the implementation limits of the browser’s C++.

			This is not a competition: Preprocessors are excellent for prototyping CSS's future with a tighter feedback loop,
			and allow us to get feedback from real developers, using these features on real projects.
		</details>
	</article>
</section>

<section id="nesting-101-section" class="code-labels">
	<header class="slide" id="nesting">
		<h1>Nesting</h1>
	</header>

	<article class="conversion slide columns">
		<h1>Nesting 101</h1>
		<pre class="language-scss delayed"><code>
			table.browser-support {
				border-collapse: collapse;

				th, td { border: 1px solid silver; }
				th { border: 0; }

				td {
					background: yellowgreen;

					&:empty { background: red; }
					> a { color: inherit; }
				}
			}
		</code></pre>
		<pre><code>
			table.browser-support {
				border-collapse: collapse; }
			table.browser-support th,
			table.browser-support td {
				border: 1px solid silver; }
			table.browser-support th {
				border: 0; }
			table.browser-support td {
				background: yellowgreen; }
			table.browser-support td:empty {
				background: red; }
			table.browser-support td > a {
				color: inherit; }
		</code></pre>
		<details class="notes">
			- Nesting was designed to avoid the duplication and error-prone-ness of overly long selectors with a shared prefix.
			- By default selectors nested inside each other are assumed to be descendants.
			- To override that, authors can use the `&` character to refer to the parent selector.
		</details>
	</article>

	<article class="conversion slide columns">
		<h1>Concatenation <span class="delayed" data-index="2">🚫</span></h1>
		<pre class="language-scss delayed persistent"><code>
			.card {
				display: grid;

				&__image {
					border-radius: 50%;
				}

				&__button {
					&--submit { background: var(--accent1); }
					&--canel { background: none; }
				}
			}
		</code></pre>
		<pre><code>
			.card {
				display: grid;
			}
			.card__image {
				border-radius: 50%;
			}
			.card__button--submit {
				background: var(--accent1);
			}
			.card__button--canel {
				background: none;
			}
		</code></pre>
		<details class="notes">
			Sass also did concatenation, to facilitate patterns like BEM.
			Because preprocessors are text-based, things like this are easier.
			This has always been out of scope for CSS and that remained constant until today, so we will not discuss it more going forwards.
			In fact, this feature was recognized as [a mistake by Sass’ designers](https://github.com/w3c/csswg-drafts/issues/2701#issuecomment-395572904) too.
		</details>
	</article>

	<article class="conversion slide columns">
		<h1>Nesting @-rules</h1>

		<pre class="language-scss delayed"><code>
			h1.make-it-pop {
				color: var(--brand-color);
				@supports (-webkit-background-clip: text) {
					background: var(--brand-gradient);
					-webkit-background-clip: text;
					color: transparent;
				}

				font-size: 250%;
				@media (width < 500px) {
					font-size: 150%;
				}
			}
		</code></pre>
		<pre><code>
			h1.make-it-pop {
				color: var(--brand-color);
				font-size: 250%;
			}
			@supports (-webkit-background-clip: text) {
				h1.make-it-pop {
					background: var(--brand-gradient);
					-webkit-background-clip: text;
					color: transparent; }
			}
			@media (width < 500px) {
				h1.make-it-pop { font-size: 150%; }
			}
		</code></pre>
	</article>

	<article class="conversion slide columns">
		<h1>Contextual styling</h1>
		<pre class="language-scss"><code>
			.callout.info {
				color: var(--color-blue-dark);
				background: var(--color-blue-light);

				.dark & { <span class="delayed">/* same as &:is(.dark *) */</span>
					color: var(--color-blue-light);
					background: var(--color-blue-dark);
				}
			}
		</code></pre>
		<pre><code>
			.callout.info {
				color: var(--color-blue-dark);
				background: var(--color-blue-light);
			}

			.dark .callout.info {
				color: var(--color-blue-light);
				background: var(--color-blue-dark);
			}
		</code></pre>
		<details class="notes">
			While rare, the ampersand can come later in the selector as well,
			usually to create variations depending on the context
		</details>
	</article>

	<article class="slide" id="when-can-we" data-credits="Giphy">
		<h1>Can we adopt this in CSS?</h1>
		<details class="notes">
			So we define the Sass syntax minus concatenation as the Holy Grail Syntax.
			However, there are some challenges in supporting this natively in CSS without modifications.
			To understand these, we need to talk a little bit about how CSS parsing work.
			It will be short, I promise.
		</details>
	</article>
</section>
<section id="parsing-section">
	<header class="slide" id="css-parsing-101">
		<h1>
			<span>CSS</span>
			<span>Parsing</span>
			<span>Crash Course</span>
		</h1>
	</header>
	<article class="slide" id="parsing">
		<h1>Parsing</h1>

		<ul class="tree arrows">
			<li>
				Characters
				<ul>
					<li>
						Tokens
						<ul>
							<li>
								Complex Constructs
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</article>
	<article class="slide language-cssgrammar columns" id="css-tokens">
		<h1>CSS tokens</h1>
		<figure>
			<object data="img/number-token.svg"></object>
			<figcaption><code>&lt;number-token></code></figcaption>
		</figure>
		<figure>
			<object data="img/hash-token.svg"></object>
			<figcaption><code>&lt;hash-token></code></figcaption>
		</figure>
		<details class="notes">
			- Parsing always begins with tokenization.
			- Tokens are the smallest meaningful units in a programming language
			- Tokens are to programming what words are to natural language.
			- Here are some examples of tokens in CSS, shown as railroad diagrams directly from the CSS Syntax spec.
		</details>
	</article>

	<article class="slide" id="tokenization">
		<h1>CSS Tokenization Example</h1>

		<pre class="language-tokenizedcss"><code class="delayed-children">
			#nav > a:hover {
				background: white url("bg.png");
				text-decoration-thickness: .1em;
			}
		</code></pre>
		<div class="legend tokenizedcss">
			<code class="hash">&lt;hash-token></code>
			<code class="whitespace">&lt;whitespace-token></code>
			<span class="literal">Single codepoint tokens (<code>&lt;delim-token></code>, <code>&lt;colon-token></code>, etc)</span>
			<code class="ident">&lt;ident-token></code>
			<code class="function">&lt;function-token></code>
			<code class="string">&lt;string-token></code>
			<code class="dimension">&lt;dimension-token></code>
		</div>

		<details class="notes">
			- The first step of parsing CSS (and any code really) is tokenization.
			- The tokenizer reads the code character by character and groups them into tokens, i.e. meaningful syntactical units.
			- For CSS, these tokens are defined in the [CSS Syntax](https://drafts.csswg.org/css-syntax/) specification.
		</details>
	</article>

	<article class="slide" id="simple-selector-grammar">
		<header>
			<h1>CSS Grammars</h1>
			<p class="subtitle">Simple selectors (simplified)</p>
		</header>

		<div>
			<script type="text/plain" class="language-cssgrammar no-whitespace-normalization">
				<type-selector> = <ident-token> | '*'
				<id-selector> = <hash-token>
				<class-selector> = '.' <ident-token>
				<pseudo-class-selector> = ':' <ident-token>
				| ':' <function-token> <any-value> ')'
			</script>
		</div>
		<dl class="grammar cheatsheet" title="Grammar cheatsheet" data-show="[] |">
			<dt data-symbol="[]">[ ]</dt>
			<dd>Grouping</dd>

			<dt data-symbol="|">|</dt>
			<dd>Alternative</dd>

			<dt data-symbol="?">?</dt>
			<dd>Optional</dd>

			<dt data-symbol="*">*</dt>
			<dd>0 or more</dd>

			<dt data-symbol="+">+</dt>
			<dd>1 or more</dd>

			<dt data-symbol="#">#</dt>
			<dd>1+, comma-separated</dd>
		</dl>

		<details class="notes">
			- The next step is parsing, which is the process of grouping tokens into constructs.
			- How this happens is defined in a compact form called a grammar.
			- [`&lt;any-value>`](https://drafts.csswg.org/css-syntax-3/#typedef-any-value)
			is a special token defined to allow any stream of tokens except open structures (unmatched parentheses, brackets, braces, broken strings, etc).
			- This is a simplified version. [Full selector grammmar](https://www.w3.org/TR/selectors/#grammar)
			- [Full declaration grammar](https://www.w3.org/TR/css-syntax-3/#grammar)
		</details>
	</article>

	<article class="slide" id="simple-selector-grammar">
		<header>
			<h1>CSS Grammars</h1>
			<p class="subtitle">Simple selectors (simplified)</p>
		</header>

		<div>
			<script type="text/plain" class="language-cssgrammar no-whitespace-normalization">
				<pseudo-class-selector> = ':' <ident-token>
				| ':' <function-token> <any-value> ')'
				<pseudo-element-selector> = ':' <pseudo-class-selector>
			</script>
			<script type="text/plain" class="language-cssgrammar no-whitespace-normalization delayed persistent">
				<attr-matcher> = [ '~' | '|' | '^' | '$' | '*' ]? '='
				<attribute-selector> = '[' <ident-token> <attr-matcher>
					[ <string-token> | <ident-token> ]? ']'
			</script>
		</div>
		<dl data-clone=".grammar.cheatsheet" data-show="[] | ?"></dl>

		<details class="notes">
			- The next step is parsing, which is the process of grouping tokens into constructs.
			- How this happens is defined in a compact form called a grammar.
			- [`&lt;any-value>`](https://drafts.csswg.org/css-syntax-3/#typedef-any-value)
			is a special token defined to allow any stream of tokens except open structures (unmatched parentheses, brackets, braces, broken strings, etc).
			- This is a simplified version. [Full selector grammmar](https://www.w3.org/TR/selectors/#grammar)
			- [Full declaration grammar](https://www.w3.org/TR/css-syntax-3/#grammar)
		</details>
	</article>

	<article class="slide language-cssgrammar tree-children md dont-resize tree-flushend progressive-subtree arrows" id="lookahead">
		- Start
			- `&lt;ident-token>`
				- `&lt;type-selector>`
			- `&lt;hash-token>`
				- `&lt;id-selector>`
			- `'.'`
				- `&lt;class-selector>`
			- `'['`
				- `&lt;attribute-selector>`
			- `':'`
				- `&lt;ident-token>`
					- `&lt;pseudo-class-selector>`
				- `':'`
					- `&lt;pseudo-element-selector>`


		<details class="notes">
			- Note that for most of these, we can tell what we have from the very first token.
			Only to distinguish pseudo-classes from pseudo-elements do we actually need two tokens, i.e. we need to "look ahead".
			- This is not a coincidence, it is by design.
			- Being able to determine the construct from the current token and by looking ahead at a fixed number of tokens
			is called "fixed lookahead" or LL(k) and is a very desirable property in parsers.
			- The CSS parser specifically is LL(1), i.e. needs to only look ahead at most one token.
		</details>
	</article>

	<article class="slide dont-resize" id="declaration-grammar">
		<header>
			<h1>CSS Grammars</h1>
			<p class="subtitle">Declaration (simplified)</p>

			<script type="text/plain" class="language-cssgrammar no-whitespace-normalization" data-production-indent="2">
				<declaration> = <ident-token> ':' <declaration-value> [ '!' <ident-token> ]? ';'
				<declaration-value> = [ <delim-token> | <whitespace-token>
					| <ident-token> | <hash-token>
					| <number-token> | <string-token>
					| <function-token> <any-value> ')'
					| <dimension-token> | <percentage-token> ]+
			</script>

			<dl data-clone=".grammar.cheatsheet" data-show="[] ?"></dl>

			<details class="notes">
				- [`&lt;declaration-value>`](https://drafts.csswg.org/css-syntax-3/#typedef-declaration-value)
			</details>
		</header>
	</article>

	<article class="slide dont-resize language-cssgrammar progressive-subtree" id="unbounded-lookahead">
		<h1>What could this be?</h1>

		<script type="text/plain" class="language-cssgrammar">
			<ident-token> <colon-token> <function-token> <ident-token> <comma-token>
			⮑	<ident-token> <comma-token> <ident-token> <comma-token> <ident-token>
			⮑	<comma-token> <ident-token> <comma-token> <ident-token> <)-token>
		</script>
		<div class="language-tokenizedcss delayed" style="align-self: stretch; margin-top: 2em">
			<pre><code class="delayed-children">article:is(h1, h2, h3, h4, h5, h6)</code></pre>
			<pre><code class="delayed-children">background:conic-gradient(red, yellow, lime, aqua, blue, magenta)</code></pre>
		</div>
		<details class="notes">
			- Take a look at this token stream here. Can you guess what CSS construct it represents?
			- Could it be a selector, like this one? Or maybe a declaration, like this one?
			- Let’s try to tokenize them and find out!
		</details>
	</article>

	<article class="image slide" style="background: hsl(50 74% 92%)">
		<!-- https://sketchplanations.com/the-blind-and-the-elephant -->
		<img src="img/elephant-parable.png" alt="">
		<details class="notes">
			Without nesting we wouldn’t even try both rules at once, we would know whether we’re parsing a rule or a declaration in the first place, so there is no ambiguity.
			But with nesting, every time we’re parsing the inside of a rule, we could have either.
			Would that make CSS ambiguous?
			Would it make it like the elephant in the well known parable who appeared to be different things to different blindfolded people depending on which part they touched?
		</details>
	</article>

	<article class="dont-resize slide" id="resolving-ambiguity">
		<h1>Resolving ambiguity</h1>
		<div class="language-tokenizedcss" style="align-self: stretch;">
			<pre><code>article:is(h1, h2, h3, h4, h5, h6) {</code></pre>
			<pre><code>background:conic-gradient(red, yellow, lime, aqua, blue, magenta);</code></pre>
		</div>
		<details class="notes">
			Nah, it’s not as bad as that.
			Eventually, we would read an opening brace (for a selector) or a semicolon or closing brace (for a declaration) and we'd know what we have.
			But do note that we lost that very desirable fixed lookahead property:
			we now need to read a potentially unbounded number of tokens to know what we have.
			So when we started exploring the possibility of adding Nesting to CSS natively, this was a non starter.
			No browser would implement a CSS feature that would so fundamentally change CSS parsing.
			Remember, CSS needs to be blazing fast, and backtracking is slow.
		</details>
	</article>

	<article class="history slide" id="first-proposal">
		<h1>
			<time>2013</time>
			First nesting proposal
		</h1>
		<iframe data-src="tab-specs/v0/css-nesting/Overview.html" data-url="https://tabatkins.github.io/specs/css-nesting/" frameborder="0" class="browser"></iframe>
		<details class="notes">
			[Read a copy of the proposal](./tab-specs/v0/css-nesting/Overview.html)
		</details>
	</article>

	<article class="slide columns md">
		<header>
			<h1>Syntax</h1>

			- `{ }` around nested rules
			- Optional `&`
			- No @-rule nesting
		</header>

		```css
			table.browser-support {
				border-collapse: collapse;
				{
					th, td { border: 1px solid silver; }
					th { border: 0; }
					td {
						background: yellowgreen;
						{
							&:empty { background: red; }
							> a { color: inherit; }
						}
					}
				}
			}
		```
	</article>

	<article class="history slide">
		<h1>
			<time>June 2015</time>
			PostCSS implements
		</h1>
		<iframe data-src="https://github.com/csstools/postcss-nesting/tree/d63f6b6b1efef37c11d86a84de23fe901f74123a/#readme" class="browser"></iframe>
	</article>

	<article class="dont-resize history slide columns" id="proposal2">
		<header class="md">
			<h1>
				<time>Sep 2015</time>
				New syntax
			</h1>

			- Dropped `{ }`
			- Mandatory `&` or `@nest` prefix
			- Still no @-rule nesting
		</header>
		<iframe data-src="tab-specs/v1/css-nesting/" data-url="https://tabatkins.github.io/specs/css-nesting/" class="browser"></iframe>
		<details class="notes">
			[Read a copy of the proposal](./tab-specs/v1/css-nesting/)
		</details>
	</article>

	<article class="conversion slide columns" style="--arrow-label: 'Became'">
		<h1>Changes</h1>

		<pre><code>
			.callout.info {
				color: var(--color-blue-dark);
				background: var(--color-blue-light);

				<mark>{</mark>
					.dark & {
						color: var(--color-blue-light);
						background: var(--color-blue-dark);
					}

					a { color: var(--color-blue); }
				<mark>}</mark>
			}
		</code></pre>
		<pre><code>
			.callout.info {
				color: var(--color-blue-dark);
				background: var(--color-blue-light);

				<mark>@nest </mark>.dark & {
					color: var(--color-blue-light);
					background: var(--color-blue-dark);
				}

				<mark>&</mark> a { color: var(--color-blue); }
			}
		</code></pre>
	</article>

	<article class="history slide">
		<h1>
			<time>Sep 2015</time>
			PostCSS updates
		</h1>
		<iframe data-src="https://github.com/csstools/postcss-nesting/tree/1931fbbd6a1e3ecf5aea1c73fed37307937544a3/#readme" class="browser"></iframe>
		<details class="notes">
			Interestingly, the plugin supported @-rule nesting, even though the spec did not.
		</details>
	</article>

	<article class="slide" style="background: url(img/84years.gif) center / cover" data-credits="Twentieth Century Fox / Giphy">
		<details class="notes">
			Well, not quite 84 but it sure felt like it.
			Part of the reason not much was happening was that a few people thought nesting was better served by a Houdini custom @-rule.
		</details>
	</article>

	<article class="dark slide">
		<img src="img/poll-2016.png" alt="" class="tweet">
	</article>

	<article class="history slide">
		<h1><time>Feb 2017</time> Ping #1</h1>
		<iframe data-src="https://github.com/w3c/csswg-drafts/issues/998" frameborder="0" class="browser"></iframe>
	</article>

	<article class="history slide">
		<h1><time>Mar 2018</time> Ping #2</h1>
		<iframe data-src="https://github.com/w3c/csswg-drafts/issues/2456" frameborder="0" class="browser"></iframe>
	</article>

	<article class="history slide">
		<h1><time>May 2018</time> Ping #3</h1>
		<iframe data-src="https://github.com/w3c/csswg-drafts/issues/2701" frameborder="0" class="browser"></iframe>
	</article>

	<article class="history slide">
		<h1><time>July 2018</time> CSS WG adopts spec</h1>
		<a href="https://github.com/w3c/csswg-drafts/issues/2701#issuecomment-402392212" class="browser" target="_blank"><img src="img/csswg-adopts.png" alt="" /></a>
	</article>

	<article class="dark slide" style="background: url(img/tumbleweed.gif) bottom / cover" data-credits="Giphy">
		<h1>Years pass…</h1>
	</article>

	<article class="history slide">
		<h1>
			<time>Sep 2022</time>
			State of CSS Survey
		</h1>
		<iframe data-src="https://2022.stateofcss.com/en-US" frameborder="0" class="browser"></iframe>
	</article>

	<article class="dont-resize history slide" id="css-pain-points-2022">
		<time>Oct 2022</time>
		<img src="img/css-pain-points-2022.png" alt="">
	</article>

	<article class="dont-resize history slide columns">
		<h1>
			<time>Oct 2022</time>
			Chrome suddenly very keen to implement
		</h1>
		<a href="https://groups.google.com/a/chromium.org/g/blink-dev/c/-GxQ0MIcons/m/dTi5stNrBAAJ" class="browser" target="_blank"><img src="img/itp.png" alt=""></a>
	</article>

	<article class="history slide they-said">
		<time>Oct 2022</time>
		<div class="messages delayed-children">
			<blockquote>Lea, we cannot let this ship!</blockquote>
			<blockquote>This will be used all over stylesheets. Having to prefix every rule with `&` or `@nest` will be tedious to write, easy to forget, and noisy to read.</blockquote>
			<blockquote>And it’s incompatible with `@scope`, so copying and pasting will require a ton of fixup.</blockquote>
			<blockquote>We must do something, ASAP!</blockquote>
			</blockquote>
		</div>
		<article class="person" id="elika">
			<img src="img/elika.jpg" alt="" class="person">
			<div>
				<h3>Elika Etemad</h3>
				<p>Extremely prolific CSS editor</p>
			</div>
		</article>
		<details class="notes">
			(In actuality we had a video call, and this is my recollection of the conversation)
		</details>
	</article>

	<article class="slide columns">
		<header>
			<h1>@scope</h1>
			<p class="subtitle">Proximity scope</p>
		</header>

		<div>
			<pre><code>
				.light a { color: darkmagenta; }
				.dark a { color: plum; }
			</code></pre>
			<pre class="delayed"><code>
				@scope (.light) {
					a { color: darkmagenta; }
				}

				@scope (.dark) {
					a { color: plum; }
				}
			</code></pre>
		</div>
		<script type="text/plain" class="language-html">
			<section class="dark">
				<article class="light">
					<a href="">Light link?</a>
				</article>
			</section>
			<section class="light">
				<article class="dark">
					<a href="">Dark link?</a>
				</article>
			</section>
		</script>
		<details class="notes">
			- Remember when you were first learning CSS?
			I don’t know about you, but I was very surprised to learn that proximity did not play a role in specificity at all.
			- Take a look at this markup. What color will the links be?
			Based on this CSS, they will both be `plum`.
			If we flip the order of rules, they will both be `darkmagenta`. Is this intuitive?
			- `@scope` solves this age old problem by making proximity part of the cascade.
			- In addition, it also offers “donut scope”, i.e. being able to exclude entire subtrees.
			- Just shipped in Chrome
		</details>
	</article>

	<article class="dont-resize slide history" id="breakouts">
		<h1>
			<time>Oct 2022</time>
			Further breakouts
		</h1>
		<div class="people">
			<article id="lea" class="person">
				<img src="img/lea.jpg" alt="">
				<div>
					<h3>Lea Verou</h3>
					<p>That’s me!</p>
				</div>
			</article>
			<article data-clone="#elika"></article>
			<article id="tab" class="person">
				<img src="img/tab.jpg" alt="">
				<div>
					<h3>Tab Atkins-Bittner</h3>
					<p style="white-space: nowrap;">Editor of CSS Nesting</p>
				</div>
			</article>
			<article id="mia" class="person">
				<img src="img/mia.avif" alt="">
				<div>
					<h3>Miriam Suzanne</h3>
					<p>Sass core contributor</p>
				</div>
			</article>

			<article id="jen" class="person">
				<img src="img/jen.jpg" alt="">
				<div>
					<h3>Jen Simmons</h3>
					<p>Developer Advocate @ Apple</p>
				</div>
			</article>
			<article id="brad" class="person">
				<img src="img/brad.jpg" alt="">
				<div>
					<h3>Brad Kemper</h3>
					<p>Web Designer/Developer</p>
				</div>
			</article>
		</div>
		<details class="notes">
			Shortly after, there were two seminal breakouts among these people, all seasoned CSS WG members and co-editors of several specs.
			We had general consensus that the syntax at the time needed improvement before it shipped in browsers,
			and several ideas about how to improve it.
		</details>
	</article>

	<article class="slide">
		<h1>We share with the WG</h1>
		<iframe data-src="https://github.com/w3c/csswg-drafts/issues/7834#issuecomment-1268957000" frameborder="0" class="browser"></iframe>
		<details class="notes">
			[Read summary](https://github.com/w3c/csswg-drafts/issues/7834#issuecomment-1268957000)
		</details>
	</article>

	<article class="slide">
		<h1>
			<span class="label">Easy win</span>
			& allowed everywhere
		</h1>
		<a href="https://github.com/w3c/csswg-drafts/issues/5745#issuecomment-1276466934" class="browser" target="_blank"><img src="img/&everywhere.png" alt=""></a>
		<details class="notes">
			- Just this single-handedly improved compatibility with `@scope` tenfold.
			- Even with no changes to the nesting syntax, now only selectors with `@nest` would need to be edited when moving code from a nested block to an `@scope` block.
			Still a lot of compat problems the other way though.
		</details>
	</article>

	<article class="slide" style="background: url(img/chattering.gif) bottom / cover; justify-content: start; color-scheme: dark">

		<details class="notes">
			A period of heavy activity followed.
			There were dozens of proposals, that were very hotly debated.
			In these types of discussions, the big barriers to reaching consensus are
			not only people assigning different weights to the various pros and cons,
			but also people disagreeing about what even is a pro or a con.
			For example, while most people thought that syntaxes allowing `&` to be implicit in descendants was a pro,
			for many others it was a con, because they thought it should always be mandatory because it added clarity.
		</details>
	</article>

	<article class="slide" id="resolve-ambiguity">
		<h1>Strategies to resolve ambiguity</h1>

		<ol class="pop">
			<li>Per-rule prefix</li>
			<li>Nest rules in block</li>
			<li>Parser switch</li>
		</ol>
	</article>

	<article class="slide columns" id="strategy-1">
		<header>
			<h1>
				<span class="pop">1</span> Per-rule prefix
			</h1>
			<p class="subtitle">
				Selectors of nested rules start with a disambiguating token
			</p>
		</header>

		<pre class="language-css"><code>
			ul {
				list-style: "🦄";

				<mark>&</mark> li { margin: 0; }
				<mark>&</mark> a { color: inherit; }
				<mark>@nest</mark> nav & {
					list-style: none;
				}
			}
		</code></pre>
		<pre class="language-css"><code>
			ul {
				list-style: "🦄";

				<mark>@</mark> li { margin: 0; }
				<mark>@</mark> a { color: inherit; }
				<mark>@</mark> nav & {
					list-style: none;
				}
			}
		</code></pre>

		<details class="notes">
			<ul class="pros-cons">
				<li class="pro">Backwards compat with postcss-nesting code</li>
				<li class="pro">Allows mixing rules and declarations</li>
				<li class="pro">Context-free interpretation</li>
				<li class="con">Tedious: O(N) extra syntax on the number of rules</li>
				<li class="con">Easy to forget prefix</li>
				<li class="con">Noisy to read</li>
				<li class="con">Incompatible with <code>@scope</code></li>
			</ul>
		</details>
	</article>

	<article class="slide columns" id="strategy-2">
		<header>
			<h1>
				<span class="pop">2</span>
				Nest rules in block
			</h1>
			<p class="subtitle">
				Nested rules are wrapped in a `{…}` block or @rule
			</p>
		</header>

		<pre class="language-css"><code>
			ul {
				list-style: "🦄";

				<mark>{</mark>
					li { margin: 0; }
					a { color: inherit; }
					nav & {
						list-style: none;
					}
				<mark>}</mark>
			}
		</code></pre>
		<pre class="language-css"><code>
			ul {
				list-style: "🦄";
			}
			<mark>{</mark>
				li { margin: 0; }
				a { color: inherit; }
				nav & {
					list-style: none;
				}
			<mark>}</mark>
		</code></pre>
		<pre class="language-css"><code>
			ul {
				list-style: "🦄";

				<mark>@nest {</mark>
					li { margin: 0; }
					a { color: inherit; }
					nav & {
						list-style: none;
					}
				<mark>}</mark>
			}
		</code></pre>
		<details class="notes">
			- This can be further broken down into two subcategories: block nested within the parent rule, or block that *follows* the parent rule (post-nesting)
			- There were many more ideas about what should come before the opening brace, even ASCII like `&&` or `@`, but in the end the two main options were "nothing" and `@nest`.

			<ul class="pros-cons delayed">
				<li class="pro">Unrestricted selector syntax</li>
				<li class="pro">O(1) extra syntax on the number of rules</li>
				<li class="con">No mixing of declarations and rules</li>
				<li class="con">Extra indentation level (for nested versions)</li>
				<li class="con">No clear path to inline style nesting (for post-nesting)</li>
			</ul>
		</details>
	</article>

	<article class="slide columns" id="strategy-3">
		<header>
			<h1>
				<span class="pop">3</span>
				Parser switch
			</h1>
			<p class="subtitle">
				A specific token that signifies "only rules from now on"
			</p>
		</header>

		<pre><code>
			ul {
				list-style: "🦄";

				<mark>@nest;</mark>

				li { margin: 0; }
				a { color: inherit; }
				nav & {
					list-style: none;
				}
			}
		</code></pre>
		<pre><code>
			ul {
				list-style: "🦄";

				<mark>@media</mark> (width < 500px) {
					margin-left: 1ch;
				}
				li { margin: 0; }
				a { color: inherit; }
				nav & {
					list-style: none;
				}
			}
		</code></pre>
		<pre><code>
			ul {
				list-style: "🦄";

				<mark>&</mark> li { margin: 0; }
				a { color: inherit; }
				nav & {
					list-style: none;
				}
			}
		</code></pre>
		<details class="notes">
			In this strategy, as long as we encounter a non-declaration, we assume that everything after is a rule.
			This could be a token specifically for this, such as `@nest`, or any other known rule, including a no-op `@nest`.
		</details>
	</article>

	<article class="dont-resize slide comparison columns" id="syntax-comparison">
		<table>
			<thead>
				<tr>
					<th></th>
					<th>Rule Prefix</th>
					<th>Parser switch</th>
					<th>Block inside</th>
					<th>Block after</th>
					<th>“Lea’s proposal”</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>No syntax overhead per nested rule</td>
					<td>🚫</td>
					<td>✅</td>
					<td>✅</td>
					<td>✅</td>
					<td><span class="merge"><span>✅</span><span>🚫</span></span></td>
				</tr>
				<tr>
					<td>Allows mixing rules and declarations?</td>
					<td>✅</td>
					<td>🚫</td>
					<td>🚫</td>
					<td>🚫</td>
					<td>✅</td>
				</tr>
				<tr>
					<td>Reordering not error-prone</td>
					<td>✅</td>
					<td>🚫</td>
					<td>✅</td>
					<td>✅</td>
					<td>✅</td>
				</tr>
				<tr>
					<td>Compatible with <code class="language-css">@scope</code>?</td>
					<td>🚫</td>
					<td>✅</td>
					<td>✅</td>
					<td>✅</td>
					<td>✅</td>
				</tr>
				<tr>
					<td>Same indentation level?</td>
					<td>✅</td>
					<td>✅</td>
					<td>🚫</td>
					<td>✅</td>
					<td>✅</td>
				</tr>
				<tr>
					<td>Compatible with Holy Grail Syntax?</td>
					<td>🚫</td>
					<td>✅</td>
					<td>🚫</td>
					<td>🚫</td>
					<td>✅</td>
				</tr>
				<tr>
					<td>Clear path for <code class="language-css">style</code> attribute</td>
					<td>✅</td>
					<td>✅</td>
					<td>✅</td>
					<td>🚫</td>
					<td>✅</td>
				</tr>
			</tbody>
		</table>
	</article>

	<article class="slide" id="organic-prefix-morpheus">
		<h1>Should we rule out rule prefix syntaxes?</h1>
		<img class="delayed" src="img/organic-prefix-morpheus.jpg" alt="" style="height: -webkit-fill-available">
	</article>

	<article class="dont-resize slide columns" id="leas-proposal">
		<header>
			<h1>
				“Lea’s proposal”
			</h1>
			<ul>
				<li>Any non-ident starts a nested rule</li>
				<li>Any nested rule must start with a non-ident</li>
			</ul>
		</header>
		<a href="https://github.com/w3c/csswg-drafts/issues/7834#issuecomment-1272373216" target="_blank" class="browser"><img src="img/option-3.png" alt=""></a>
		<details class="notes">
			At some point I posted a new idea: what if we went with a prefix-based syntax,
			but the prefix could be anything other than an ident?

			This came to be known as “Lea’s proposal” so for the lulz I’ll use that name for now as well.
		</details>
	</article>

	<article class="dont-resize slide columns">
		<div>
			<pre class="language-css"><code>
				ul {
					list-style: "🦄";

					.foo { }
					li { }
					> a { }
					.dark & { }
					#sidebar & { }
					nav & { }
				}
			</code></pre>
			<h2>Holy Grail Syntax</h2>
		</div>

		<div>
			<pre class="language-css"><code>
				ul {
					list-style: "🦄";

					.foo {  }
					<mark>&</mark> li { }
					> a { }
					.dark & { }
					#sidebar & { }
					<mark>:is(nav)</mark> & { }
				}
			</code></pre>
			<h2>“Lea’s Proposal”</h2>
		</div>

		<details class="notes">
			- `&` is optional. If no `&` is present, the rule is interpreted as a descendant
			- If a descendant rule starts with a type selector, then the `&` is mandatory
			- Drop `@nest` to maximize compatibility. Contextual selectors that need to start with a type selector must be rewritten.
			- It combined a lot of the advantages of prefix-based syntaxes (context independence, mixing rules and declarations),
			without the tediousness of having to add an additional prefix to every single selector.
			- Dropping `@nest` ensures full compatibility with `@scope`, and offered a clear upgrade path to the Holy Grail Syntax.
			- Proposal was generally very well received
			- Some concern that the distinction about when `&` is not optional would be confusing.
		</details>
	</article>

	<article class="slide" data-insert="#syntax-comparison"></article>

	<article class="slide columns" id="twitter-polls">
		<div>
			<h2>
				What do you want the general rule to be?
				<div class="subtitle">592 respondents</div>
			</h2>

			<div class="pie" style="--value: 42"></div>
			<div class="legend">
				<div>Mandatory <code>&</code></div>
				<div>Optional <code>&</code>
					<div class="description">(for descendants and combinators)</div>
				</div>
			</div>
		</div>
		<div class="delayed">
			<h2>
				What do you want to do in your own code?
				<div class="subtitle">1,613 respondents</div>
			</h2>

			<div class="pie" style="--value: 52"></div>
			<div class="legend md-children">
				<div>Explicit `&`</div>
				<div>Omit `&` whenever possible</div>
			</div>
		</div>
		<details class="notes">
			*(Percentages normalized to exclude "Just show results" answers)*

			**[Poll 1: What do authors prefer for their own code](https://twitter.com/LeaVerou/status/1579902585540345857)** (1,613 votes)

			Which of the following best expresses how you want to write nested CSS when it's implemented by browsers?

			- (**52%**) I want to use `&` in every selector, as I think it makes code more clear
			- (**48%**) I want to be able to omit `&` whenever possible, as it's noisy to read and a hassle to type

			**[Poll 2: What do authors want to be the general rule](https://twitter.com/LeaVerou/status/1580215877705687040)** (592 votes)

			If it were up to you, what syntax would you prefer for CSS Nesting?

			- (**42%**) `&` should be mandatory, even in descendants and combinators
			- (**58%**) `&` should be optional for descendants and combinators
		</details>
	</article>

	<article class="takeaway slide">
		<h1>
			Use data to short-circuit long debates
			<div class="subtitle">Even very imperfect data works better than arguing</div>
		</h1>
		<details class="notes">
			- The more statistics-minded among you may be horrified at the thought of using Twitter polls as a source of data.
			“But the snowballing bias!” I can hear you crying.
			- Yes, Twitter polls are not perfect, but nothing gets you the same amount of data in the same amount of time,
			and with their flaws and all, they’re still better than pure speculation.
			- In general, data works wonders in short-circuiting discussions that do not seem to be converging towards consensus.
			- Don’t worry about the data being imperfect.
			For reaching consensus, it's more important to get data fast, than to minimize all possible sources of bias.
			Getting good data will be no help if it arrives long after the discussion has ended.
			It’s like prototyping: iterating fast is more important than getting it right the first time.
		</details>
	</article>

	<article class="dont-resize slide columns" id="finalists">
		<header>
			<h1>Finalists</h1>

			<ol class="pop language-none">
				<li>(Then) current spec</li>
				<li>Parser switch
					<ol class="md-children delayed persistent">
						<li>Any @rule</li>
						<li>Any @rule + `&`</li>
						<li>Any non-ident</li>
					</ol>
				</li>
				<li>“Lea’s proposal”</li>
				<li>Post-nesting proposal
					<ol class="md-children delayed">
						<li>`@nest {}`</li>
						<li>`& {}`</li>
						<li>`{}`</li>
					</ol>
				</li>
			</ol>
		</header>
		<iframe data-src="https://github.com/w3c/csswg-drafts/blob/2535b93ca241a1db5a29c47c5b22c5b1d0be2e71/css-nesting-1/proposals.md" frameborder="0" class="browser"></iframe>
	</article>

	<article class="history slide" id="consensus-option-3">
		<h1>
			<time>26 Oct 2022</time>
			WG consensus to switch to Option 3
		</h1>
		<div class="they-said">
			<div class="messages autoplay">
				<blockquote>
					While I initially supported option 1, having looked through the details, option 3 is very good
				</blockquote>
				<blockquote>
					It most of the time gives you the ability to write like in Sass, with one awkward exception that’s easy to tell apart
				</blockquote>
				<blockquote>
					The rule for whether you need [an ampersand] or not is very clear, and this does allow us to be close to Sass
				</blockquote>
			</div>
			<article data-clone="#tab"></article>
		</div>
		<details class="notes">
			- [Minutes](https://github.com/w3c/csswg-drafts/issues/7834#issuecomment-1284314893)
			- Note that the resolution was that we prefer Option 3 over the current spec (at the time),
			but Option 3 vs Option 4 would be discussed later.
		</details>
	</article>

	<article class="history slide">
		<h1>
			<time>27 Oct 2022</time>
			🚀 Spec updated
			🚀 Chrome implementation updated
		</h1>
		<details class="notes">
			- [Spec updated](https://github.com/w3c/csswg-drafts/issues/7834#issuecomment-1293948163)
			- [Chrome changes in review](https://github.com/w3c/csswg-drafts/issues/7834#issuecomment-1294064507)
		</details>
	</article>

	<article class="history slide columns">
		<time>June 2018</time>
		<h1>
			2022 was not the first time I proposed that idea 🤫
		</h1>
		<a href="https://github.com/w3c/csswg-drafts/issues/2701#issuecomment-394785270" class="browser"><img src="img/option-3-2018.png" alt=""></a>
	</article>

	<article class="takeaway slide">
		<h1>
			If your idea is rejected, try again later? 😀
			<div class="subtitle">(data helps too)</div>
		</h1>
	</article>

	<article class="history slide">
		<h1>
			<time>15 Dec 2022</time>
			WebKit polls developers once more
		</h1>
		<iframe data-src="https://webkit.org/blog/13607/help-choose-from-options-for-css-nesting-syntax/" class="browser"></iframe>
	</article>

	<article class="history slide">
		<h1>
			<time>15 Dec 2022</time>
			Option 3 wins by a landslide
		</h1>
		<a href="https://webkit.org/blog/13607/help-choose-from-options-for-css-nesting-syntax/#:~:text=Which%20option%20is%20best%20for%20the%20future%20of%20CSS%3F" class="browser" target="_blank"><img src="img/webkit-poll.png" alt=""></a>
	</article>

	<article class="history slide">
		<h1>
			<time>21 Dec 2022</time>
			Final WG resolution to adopt Option 3
		</h1>
		<details class="notes">
			[Minutes](https://lists.w3.org/Archives/Public/www-style/2022Dec/0015.html)
		</details>
	</article>
</section>

<section>
	<header class="slide doneyet" id="towards-backtracking" data-credits="Giphy">
		<h1>So… are we done now?</h1>
	</header>

	<article class="history slide">
		<h1>
			<time>26 Oct 2022</time>
		</h1>
		<iframe src="https://github.com/w3c/csswg-drafts/issues/7961" frameborder="0" class="browser"></iframe>
	</article>

	<article class="slide">
		<h1>
			<span class="label">Core idea</span>
			Allow backtracking, as an edge case
		</h1>
		<details class="notes">
			- What if we could minimize the number of cases that require backtracking so much it becomes exceedingly rare?
			- “Asymptotically fixed lookahead” 😅
		</details>
	</article>

	<article class="slide">
		<h1>
			<div class="label">Observation 1</div>
			Far more declarations than nested rules
		</h1>
		<details class="notes">
			Quite trivially for most existing stylesheets, but this holds true even for stylesheets that use nesting quite heavily.
		</details>
	</article>

	<article class="slide">
		<h1>
			<div class="label">Observation 2</div>
			Very few nested selectors are actually ambiguous (&lt; 2%)
		</h1>
	</article>

	<article class="slide language-cssgrammar tree-children dont-resize tree-flushend arrows" id="backtracking-algorithm">
		<ul>
			<li>
				<span class="start">Start</span>
				<ul>
					<li><code>&lt;ident-token&gt;</code>
						<ul class="delayed persistent" data-index="2">
							<li><code>':'</code>
								<ul class="delayed persistent" data-index="4">
									<li><code>&lt;ident-token&gt;</code>
										<ul class="delayed persistent" data-index="7">
											<li>
												<img class="end ambiguous" src="img/bazinga.svg">
											</li>
										</ul>
									</li>
									<li><code>':'</code>
										<ul class="delayed persistent" data-index="5">
											<li>
												<span class="end rule">✅ Rule</span>
											</li>
										</ul>
									</li>
									<li>
										<em>(Any other token)</em>
										<ul class="delayed persistent" data-index="6">
											<li>
												<span class="end declaration">✅ Declaration</span>
											</li>
										</ul>
									</li>
								</ul>
							</li>
							<li>
								<em>(Any other token)</em>
								<ul class="delayed persistent" data-index="3">
									<li>
										<span class="end rule">✅ Rule</span>
									</li>
								</ul>
							</li>
						</ul>
					</li>
					<li>
						<em>(Any other token)</em>
						<ul class="delayed persistent" data-index="1">
							<li>
								<span class="end rule">✅ Rule</span>
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>

		<details class="notes">
			For simplicity, option 3 requires rules to not start with an ident.
			However, not everything that starts with an ident is actually ambiguous.
		</details>
	</article>

	<article class="slide">
		<h1>
			Parse <img class="end ambiguous" src="img/bazinga.svg" style="height: 1.1em; vertical-align: -0.25em;"> as declarations, backtrack if no luck
		</h1>
		<details class="notes">
			- 0 perf impact for declarations, and tiny for 2% of rules
		</details>
	</article>

	<article class="slide" id="implementor-feedback">
		<h1>Implementer Feedback</h1>
		<div class="they-said reverse delayed">
			<div class="messages autoplay">
				<blockquote>This may work; needs measurements to assess impact</blockquote>
			</div>
			<div class="person" id="emilio">
				<img src="img/firefox-logo.svg" alt="">
				<div>
					<h3>Emilio A.</h3>
					<p>Mozilla</p>
				</div>
			</div>
		</div>
		<div class="they-said delayed">
			<div class="messages autoplay">
				<blockquote>I want to get any syntax specified and be done with it.</blockquote>
				<blockquote>So NAK. I won’t be spending resources on this. Non-starter for us.</blockquote>
			</div>
			<div class="person" id="emilio">
				<img src="img/chrome-logo.svg" alt="">
				<div>
					<h3>Steinar G.</h3>
					<p>Google</p>
				</div>
			</div>
		</div>
		<div class="they-said reverse delayed">
			<div class="messages autoplay">
				<blockquote>If Chrome has trouble with this, we will too 🤷🏼</blockquote>
			</div>
			<div class="person" id="emilio">
				<img src="img/safari-logo.png" alt="">
				<div>
					<h3>(Redacted)</h3>
					<p>Apple</p>
				</div>
			</div>
		</div>
	</article>

	<article class="slide they-said" id="peter-fo">
		<div class="messages autoplay">
			<blockquote>Formal Objection if feasibility of the Holy Grail Syntax is not investigated for reals</blockquote>
		</div>
		<div class="person">
			<img src="img/peter.png" alt="">
			<div>
				<h3>Peter Linss</h3>
				<p>W3C TAG co-chair</p>
			</div>
		</div>
	</article>

	<article class="history slide">
		<h1>
			<time>Oct 2022 - Jan 2023</time>
			Tab, Peter, and others refine algorithm further
		</h1>
	</article>

	<article class="history slide columns">
		<h1>
			<time>Mar 2023</time>
			Holy Grail Syntax actually possible in Chrome! 🎉
		</h1>
		<a href="https://github.com/w3c/csswg-drafts/issues/7961#issuecomment-1489883575" class="browser" target="_blank"><img src="img/backtracking-possible.png" alt=""></a>
	</article>

	<article class="takeaway slide">
		<h1>
			Take “Not implementable” with a grain of salt
		</h1>
		<details class="notes">
			It’s common for things that originally seemed not implementable to prove out to be implementable upon closer inspection.
			This is by far not the only example. Container queries, `:has()` are two big others.
		</details>
	</article>

	<article class="takeaway slide">
		<h1>
			100% seems a lot easier once you’re at 80%
		</h1>
		<details class="notes">
			The fact that we were almost there definitely played a role in people being motivated to get all the way there.
			And getting to 80% requires less than 80% of the effort.
		</details>
	</article>

	<article class="takeaway slide">
		<h1>
			Favor internal complexity over external complexity
		</h1>
		<details class="notes">
			- Getting to the syntax that is simpler on the outside meant that parsing is now significantly more complex.
			But usually offloading complexity inwards is a worthy tradeoff.
			- Each interface is used by far more people than the number of people who have to deal with the internals,
			and the internals can always be improved down the line.
			- In fact, the opposite is a usaiblity antipattern: degrading the user experience to make implementation easier.
		</details>
	</article>

	<article class="slide">
		<h1>Current state</h1>
		<iframe src="https://caniuse.com/css-nesting" frameborder="0" class="browser"></iframe>
	</article>

	<article class="slide doneyet" data-credits="Giphy">
		<h1>Surely we’re done now?!</h1>
	</article>

	<article class="slide md">
		<h1>Still lots to do!</h1>

		- Nesting in `style=""`
		- CSS OM
		- [Cascade of declarations after rules](https://webkit.org/blog/14571/css-nesting-and-the-cascade/)
		- [and a lot more…](https://github.com/w3c/csswg-drafts/issues?q=is%3Aopen+label%3Acss-nesting-1+sort%3Aupdated-desc)
	</article>
</section>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.1/font/bootstrap-icons.css" />
<footer class="slide">
	<img src="../shared/img/stickers.JPG" class="stickers delayed" alt="">
	<p class="stickercaption delayed">Come get a sticker (and say hi!) ---></p>
	<header>
		<h1>Thank you!</h1>
		<p class="subtitle">Slides at <a href="https://projects.verou.me/talks/css-nesting/">projects.verou.me/talks/css-nesting/</a><span style="color: canvastext">*</span></p>
		<p style="font-size: 60%; position: absolute; right: 2em; bottom: 2em;">
			* Yes, they use nesting, natively interperted by the browser.
		</p>
	</header>
	<dl class="cheatsheet" title="Reach out!">
		<dt class="bi bi-link-45deg"></dt>
		<dd>
			<a href="https://lea.verou.me">lea.verou.me</a>
		</dd>

		<dt class="bi bi-envelope-open"></dt>
		<dd>
			lea@verou.me
		</dd>

		<dt>
			<i class="bi bi-twitter"></i>
			<i class="bi bi-github"></i>
			<i class="bi bi-linkedin"></i>
			<i class="bi bi-threads"></i>
		</dt>
		<dd>leaverou</dd>

		<dt class="bi bi-mastodon"></dt>
		<dd>@leaverou@front-end.social</dd>
	</dl>
</footer>

<article class="slide white">
	<img src="http://localhost:8002/Coda%20presentation/designftw.png" alt="" class="browser" data-url="https://designftw.mit.edu">
</article>

</body>
</html>