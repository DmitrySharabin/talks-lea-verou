<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">

	<link rel="dns-prefetch" href="https://lea.verou.me">
	<link rel="dns-prefetch" href="https://cdn.jsdelivr.net">
	<title>A story of ðŸ§Š ice, ðŸ”¥ fire, and ðŸª† CSS Nesting</title>
	<link rel="icon" href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><text y=".9em" font-size="90">ðŸª†</text></svg>' />

	<link href="https://inspirejs.org/inspire.css" rel="stylesheet" />
	<link href="https://inspirejs.org/theme.css" rel="stylesheet" />
	<link href="theme.css" rel="stylesheet" />
	<link href="talk.css" rel="stylesheet" />

	<script src="../shared/js/bliss.shy.min.js"></script>
	<script src="../shared/js/prism.js" data-manual></script>
	<!-- <script src="https://incrementable.verou.me/incrementable.js" type="module"></script> -->
	<script src="https://inspirejs.org/inspire.mjs" type="module"></script>
	<script src="talk.js" type="module"></script>
</head>
<body class="language-css no-docs no-media" data-markdown-elements="details.notes, .md, .they-said blockquote">

<header id="intro" class="slide dont-resize">
	<h1>A story of
		<div>
			<span class="ice">ice</span>,
			<span class="fire">fire</span>
		</div>
		&
		<span class="nesting">CSS <span>N<span>e<span>s<span>t<span>i<span>n<span>g</span></span></span></span></span></span></span></span>
	</h1>
	<p class="attribution">By <a href="http://lea.verou.me">Lea Verou</a> (<a href="http://twitter.com/leaverou">@LeaVerou</a>)</p>
</header>

<section id="background" class="code-labels">
	<article class="slide columns c3">
		<h1>
			CSS Preprocessors
		</h1>
		<div>
			<time>2006</time>

			<h2>
				<img src="img/sass-logo.svg" alt="Sass">
			</h2>
			<a href="https://sass-lang.com">sass-lang.com</a>
		</div>
		<div>
			<time>2009</time>

			<h2>
				<img src="img/less-logo.png" alt="Less">
			</h2>
			<a href="https://lesscss.org/">lesscss.org</a>
		</div>
		<div>
			<time>2010</time>

			<h2>
				<img src="img/stylus-logo.svg" alt="Stylus">
			</h2>
			<a href="https://stylus-lang.com/">stylus-lang.com</a>
		</div>
		<details class="notes">
			Our story begins back in the ancient 2006, with the appearance of the first CSS preprocessor that actually became popular.
			It was called Sass, and it was written in Ruby.
			Two more appeared in the following years: Less, written in JavaScript, and Stylus, also written in JavaScript.
			CSS Preprocessors are languages that compile to CSS, allowing easier syntax without it having to be suppprted in browsers.
			There were other preprocessors before Sass, but they didn't really take off.

			A lot changed in the CSS landscape once preprocessors appeared.
		</details>
	</article>

	<article class="slide">
		<h1>Top 3 preprocessor features</h1>

		<ul>
			<li style="list-style: 'ðŸ¥‡';">Variables</li>
			<li style="list-style: 'ðŸ¥ˆ';">Calculations</li>
			<li style="list-style: 'ðŸ¥‰';">Nesting</li>
		</ul>
		<details class="notes">
			Note that all three features are about reuse: variables and calculations are about value reuse, nesting is selector reuse.
			This is what CSS was desperately lacking: reusability mechanisms to make it more maintainable.
		</details>
	</article>

	<article class="slide columns conversion code-labels" id="sass-variables">
		<h1>Sass Variables</h1>

		<div>
			<pre class="language-scss"><code>
				$color-accent: oklch(50% .3 180);
				$font-sans: Helvetica, sans-serif;

				body {
					font: 100%/1.5 $font-sans;
					accent-color: $color-accent;
				}
			</code></pre>
		</div>
		<div>
			<pre class="language-css delayed"><code>
				body {
					font: 100%/1.5 Helvetica, sans-serif;
					accent-color: oklch(.5 .3 180);
				}
			</code></pre>
		</div>
		<details class="notes">
			Preprocessor variables (like every preprocessor feature)
			are compiled to CSS, which is then sent to the browser.
		</details>
	</article>

	<article class="slide columns">
		<h1>Native CSS Variables</h1>

		<div>
			<pre data-clone="#sass-variables pre.language-scss"></pre>
		</div>
		<div>
			<pre class="language-css delayed"><code>
				:root {
					--font-sans: Helvetica, sans-serif;
					--color-accent: oklch(.5 .3 180);
				}

				body {
					font: 100%/1.5 var(--font-sans);
					accent-color: var(--color-accent);
				}
			</code></pre>
		</div>
		<details class="notes">
			At first glance, the CSS version looks more clumsy and verbose.
			Why not just adopt one of the preprocessor syntaxes?
		</details>
	</article>

	<article class="slide columns" id="reactive-css-variables">
		<h1 class="container">CSS Variable Reactivity</h1>
		<pre><code>
			.container {
				--accent-color: oklch(60% .15 var(--angle, 0deg));
			}
			h1, button { color: var(--accent-color); }
			button {
				border: .1em solid var(--accent-color);
			}
			button.primary, button:hover {
				background: var(--accent-color);
				color: white;
			}
		</code></pre>
		<pre class="delayed"><code>
			@property --angle {
				syntax: "&lt;angle>";
				inherits: true;
				initial-value: 0deg;
			}
			@keyframes angle-spin {
				to { --angle: 1turn; }
			}
			.container {
				animation: angle-spin 4s linear infinite;
			}
		</code></pre>
		<style data-slide>
			button {
				background: transparent border-box;
				border-radius: .2em;
				padding: .15em .6em;
				font-weight: 500;
				letter-spacing: inherit;
			}
		</style>
		<style data-slide data-clone="code"></style>
		<style data-slide data-clone="pre + pre > code"></style>
		<div class="container">
			<button>Log in</button>
			<button class="primary">Sign up</button>
		</div>
		<details class="notes">
			However, if you look more closely, the CSS syntax has several advantages.
			CSS variables are actual CSS properties, and share their reactive nature.
		</details>
	</article>

	<!-- TODO: Maybe demo to show that MQs can also tweak variables -->

	<article class="conversion slide columns" id="sass-math">
		<h1>Sass Calculations</h1>

		<div>
			<pre class="language-scss"><code>
				$spacing: 16px;

				button {
					padding: $spacing / 2;
				}
			</code></pre>
		</div>
		<div>
			<pre><code>
				button {
					padding: 8px;
				}
			</code></pre>
		</div>
	</article>

	<article class="conversion slide columns" id="sass-math">
		<h1>Sass Calculations</h1>

		<div>
			<pre class="language-scss"><code>
				$spacing: 16px;

				textarea {
					padding: $spacing / 2;
					width: 100% - $spacing;
				}
			</code></pre>
		</div>
		<div>
			<pre class="language-none error"><code>
				Incompatible units: 'px' and '%'.
			</code></pre>
		</div>
	</article>

	<article class="slide columns">
		<header>
			<h1>Native CSS Calculations</h1>
			<p class="subtitle">calc() in 2013</p>
		</header>

		<div>
			<pre data-clone="#sass-math pre.language-scss"></pre>
		</div>
		<div>
			<pre><code>
				:root {
					--spacing: 16px;
				}

				textarea {
					padding: calc(var(--spacing) / 2);
					width: calc(100% - var(--spacing));
				}
			</code></pre>
		</div>
	</article>

	<article class="conversion slide columns">
		<h1>Sass Color Calculations</h1>

		<div>
			<pre class="language-scss"><code>
				$color-accent: #037465;

				button {
					background: lighten($color-accent, 20%);
				}
			</code></pre>
		</div>
		<div>
			<pre><code>
				button {
					background: #06d7bc;
				}
			</code></pre>
		</div>
	</article>

	<article class="conversion slide columns">
		<h1>Butâ€¦</h1>

		<div>
			<pre class="language-scss"><code>
				$color-accent: oklch(.5 .3 180);

				button {
					background: lighten($color-accent, 20%);
				}
			</code></pre>
		</div>
		<div>
			<pre class="language-none error"><code>
				argument `$color` of `lighten($color, $amount)` must be a color
			</code></pre>
		</div>
	</article>

	<article class="slide">
		<header>
			<h1>CSS Relative Colors</h1>
			<p class="subtitle"><a href="https://caniuse.com/css-relative-colors">Coming soon!</a></p>
		</header>

		<div>
			<pre><code>
				button {
					background: oklch(from var(--color-accent) calc(l * 1.2) c h);
				}
			</code></pre>

			<pre class="delayed"><code>
				button {
					background: oklch(from var(--color-accent) calc(l + .2) c h);
				}
			</code></pre>
		</div>
		<details class="notes">
			You may be starting to see a pattern:
			Once more the native CSS version involves clunkier syntax but is more powerful.
		</details>
	</article>

	<article class="slide" id="preprocessors-vs-css">
		<table>
			<thead>
				<tr>
					<th></th>
					<th>Preprocessors</th>
					<th>CSS</th>
				</tr>
			</thead>
			<tbody class="delayed-children">
				<tr>
					<th>Performance requirements</th>
					<td class="win">Looser</td>
					<td>Stricter</td>
				</tr>
				<tr>
					<th>Syntax restrictions</th>
					<td class="win">Looser</td>
					<td>Stricter</td>
				</tr>
				<tr>
					<th>Iteration speed</th>
					<td class="win">Faster</td>
					<td>Slower</td>
				</tr>
				<tr>
					<th>Context Awareness</th>
					<td>None</td>
					<td class="win">Full</td>
				</tr>
				<tr>
					<th>Reactivity</th>
					<td>None</td>
					<td class="win">Yes</td>
				</tr>
				<tr>
					<th>Implementation Limits</th>
					<td>CSS</td>
					<td class="win">C++</td>
				</tr>
			</tbody>
		</table>
		<details class="notes">
			Preprocessors and native CSS syntax have different strengths and weaknesses.
			- Native CSS syntax is subject to much stricter performance requirements.
			Preprocessors only run once, split out CSS, and are done with it, so anything that runs in speed acceptable for a build tool is fair game.
			CSS doesn't have that luxury. CSS code can be changed and need to re-run millions of times per second, so it has to be blazing fast.
			This means that certain things that are simple for preprocessors are very hard to do in CSS.
			- Native CSS syntax is subject to much stricter syntax restrictions.
			Any syntax added to CSS has to be *both* backwards compatible with existing CSS as well as forwards compatible with any possible future CSS.
			While this is also a concern for preprocessors, things are a bit easier there due to versioning.
			- Preprocessors have much faster iteration speed.
			Adding a new feature requires consensus among the preprocessor maintainers, then it can be implemented and shipped soon after.
			Adding a new feature to CSS requires consensus among the CSS WG, then someone to write the specification, iterate on it, ensure the spec is implementable,
			convince browser vendors to implement it, then wait for it to be implemented, then wait for it to be shipped, then wait for it to be widely adopted.
			The length of this process varies, but it's usually measured in years.
			- However, native CSS syntax has full context awareness.
			It knows what the viewport size is, which media queries apply, what is supported and what isn't, what are the metrics of the font being used, etc.
			This allows native CSS syntax to be a lot more powerful.
			- Native CSS syntax is reactive. If any of its components change, it will update automatically.
			Preprocessor syntax is executed top to bottom, analogously to imperative programming.
			- Lastly, because preprocessor syntax has to be ultimately compiled to CSS, it is subject to the same implementation limits as CSS.
			However, native CSS syntax can *extend* the bounds of what is possible in CSS, and is only bound by the implementation limits of the browserâ€™s C++.

			This is not a competition: Preprocessors are excellent for prototyping CSS's future with a tighter feedback loop,
			and allow us to get feedback from real developers, using these features on real projects.
		</details>
	</article>
</section>

<section id="nesting-101-section" class="code-labels">
	<header class="slide" id="nesting">
		<h1>Nesting</h1>
	</header>

	<article class="conversion slide columns">
		<h1>Nesting 101</h1>
		<pre class="language-scss delayed"><code>
			table.browser-support {
				border-collapse: collapse;

				th, td { border: 1px solid silver; }
				th { border: 0; }

				td {
					background: yellowgreen;

					&:empty { background: red; }
					> a { color: inherit; }
				}
			}
		</code></pre>
		<pre><code>
			table.browser-support {
				border-collapse: collapse; }
			table.browser-support th,
			table.browser-support td {
				border: 1px solid silver; }
			table.browser-support th {
				border: 0; }
			table.browser-support td {
				background: yellowgreen; }
			table.browser-support td:empty {
				background: red; }
			table.browser-support td > a {
				color: inherit; }
		</code></pre>
		<details class="notes">
			- Nesting was designed to avoid the duplication and error-prone-ness of overly long selectors with a shared prefix.
			- By default selectors nested inside each other are assumed to be descendants.
			- To override that, authors can use the `&` character to refer to the parent selector.
		</details>
	</article>

	<article class="conversion slide columns">
		<h1>Concatenation</h1>
		<pre class="language-scss delayed"><code>
			.card {
				display: grid;

				&__image {
					border-radius: 50%;
				}

				&__button {
					&--submit { background: var(--accent1); }
					&--canel { background: none; }
				}
			}
		</code></pre>
		<pre><code>
			.card {
				display: grid;
			}
			.card__image {
				border-radius: 50%;
			}
			.card__button--submit {
				background: var(--accent1);
			}
			.card__button--canel {
				background: none;
			}
		</code></pre>
		<details class="notes">
			Sass also did concatenation, to facilitate patterns like BEM.
			Because preprocessors are text-based, things like this are easier.
			This has always been out of scope for CSS and that remained constant until today, so we will not discuss it more going forwards.
			In fact, this feature was recognized as [a mistake by Sassâ€™ designers](https://github.com/w3c/csswg-drafts/issues/2701#issuecomment-395572904) too.
		</details>
	</article>

	<article class="conversion slide columns">
		<h1>Nesting @-rules</h1>

		<pre class="language-scss delayed"><code>
			h1.make-it-pop {
				color: var(--brand-color);
				@supports (-webkit-background-clip: text) {
					background: var(--brand-gradient);
					-webkit-background-clip: text;
					color: transparent;
				}

				font-size: 250%;
				@media (width < 500px) {
					font-size: 150%;
				}
			}
		</code></pre>
		<pre><code>
			h1.make-it-pop {
				color: var(--brand-color);
				font-size: 250%;
			}
			@supports (-webkit-background-clip: text) {
				h1.make-it-pop {
					background: var(--brand-gradient);
					-webkit-background-clip: text;
					color: transparent; }
			}
			@media (width < 500px) {
				h1.make-it-pop { font-size: 150%; }
			}
		</code></pre>
	</article>

	<article class="conversion slide columns">
		<h1>Contextual styling</h1>
		<pre class="language-scss"><code>
			.callout.info {
				color: var(--color-blue-dark);
				background: var(--color-blue-light);

				.dark & { <span class="delayed">/* same as &:is(.dark *) */</span>
					color: var(--color-blue-light);
					background: var(--color-blue-dark);
				}
			}
		</code></pre>
		<pre><code>
			.callout.info {
				color: var(--color-blue-dark);
				background: var(--color-blue-light);
			}

			.dark .callout.info {
				color: var(--color-blue-light);
				background: var(--color-blue-dark);
			}
		</code></pre>
		<details class="notes">
			While rare, the ampersand can come later in the selector as well,
			usually to create variations depending on the context
		</details>
	</article>



	<article class="slide" id="when-can-we" data-credits="Giphy">
		<h1>Can we adopt this in CSS?</h1>
	</article>
</section>
<section id="parsing-section">
	<header class="slide" id="css-parsing-101">
		<h1>
			<span>CSS</span>
			<span>Parsing</span>
			<span>Crash Course</span>
		</h1>
	</header>
	<article class="slide" id="parsing">
		<h1>Parsing</h1>

		<ul class="tree arrows">
			<li>
				Characters
				<ul>
					<li>
						Tokens
						<ul>
							<li>
								Complex Constructs
							</li>
						</ul>
					</li>
				</ul>
			</li>
		</ul>
	</article>
	<article class="slide language-cssgrammar columns" id="css-tokens">
		<h1>CSS tokens</h1>
		<figure>
			<object data="img/number-token.svg"></object>
			<figcaption><code>&lt;number-token></code></figcaption>
		</figure>
		<figure>
			<object data="img/hash-token.svg"></object>
			<figcaption><code>&lt;hash-token></code></figcaption>
		</figure>
		<details class="notes">
			- Parsing always begins with tokenization.
			- Tokens are the smallest meaningful units in a programming language
			- Tokens are to programming what words are to natural language.
			- Here are some examples of tokens in CSS, shown as railroad diagrams directly from the CSS Syntax spec.
		</details>
	</article>

	<article class="slide" id="tokenization">
		<h1>CSS Tokenization Example</h1>

		<pre class="language-tokenizedcss"><code class="delayed-children">
			#nav > a:hover {
				background: white url("bg.png");
				text-decoration-thickness: .1em;
			}
		</code></pre>
		<div class="legend tokenizedcss">
			<code class="hash">&lt;hash-token></code>
			<code class="whitespace">&lt;whitespace-token></code>
			<span class="literal">Single codepoint tokens (<code>&lt;delim-token></code>, <code>&lt;colon-token></code>, etc)</span>
			<code class="ident">&lt;ident-token></code>
			<code class="function">&lt;function-token></code>
			<code class="string">&lt;string-token></code>
			<code class="dimension">&lt;dimension-token></code>
		</div>

		<details class="notes">
			- The first step of parsing CSS (and any code really) is tokenization.
			- The tokenizer reads the code character by character and groups them into tokens, i.e. meaningful syntactical units.
			- For CSS, these tokens are defined in the [CSS Syntax](https://drafts.csswg.org/css-syntax/) specification.
		</details>
	</article>

	<article class="slide" id="simple-selector-grammar">
		<header>
			<h1>CSS Grammars</h1>
			<p class="subtitle">Simple selectors (simplified)</p>
		</header>

		<div>
			<script type="text/plain" class="language-cssgrammar no-whitespace-normalization">
				<type-selector> = <ident-token> | '*'
				<id-selector> = <hash-token>
				<class-selector> = '.' <ident-token>
				<pseudo-class-selector> = ':' <ident-token>
				| ':' <function-token> <any-value> ')'
			</script>
		</div>
		<dl class="grammar cheatsheet" title="Grammar cheatsheet" data-show="[] |">
			<dt data-symbol="[]">[ ]</dt>
			<dd>Grouping</dd>

			<dt data-symbol="|">|</dt>
			<dd>Alternative</dd>

			<dt data-symbol="?">?</dt>
			<dd>Optional</dd>

			<dt data-symbol="*">*</dt>
			<dd>0 or more</dd>

			<dt data-symbol="+">+</dt>
			<dd>1 or more</dd>

			<dt data-symbol="#">#</dt>
			<dd>1+, comma-separated</dd>
		</dl>

		<details class="notes">
			- The next step is parsing, which is the process of grouping tokens into constructs.
			- How this happens is defined in a compact form called a grammar.
			- [`&lt;any-value>`](https://drafts.csswg.org/css-syntax-3/#typedef-any-value)
			is a special token defined to allow any stream of tokens except open structures (unmatched parentheses, brackets, braces, broken strings, etc).
			- This is a simplified version. [Full selector grammmar](https://www.w3.org/TR/selectors/#grammar)
			- [Full declaration grammar](https://www.w3.org/TR/css-syntax-3/#grammar)
		</details>
	</article>

	<article class="slide" id="simple-selector-grammar">
		<header>
			<h1>CSS Grammars</h1>
			<p class="subtitle">Simple selectors (simplified)</p>
		</header>

		<div>
			<script type="text/plain" class="language-cssgrammar no-whitespace-normalization">
				<pseudo-class-selector> = ':' <ident-token>
				| ':' <function-token> <any-value> ')'
				<pseudo-element-selector> = ':' <pseudo-class-selector>
			</script>
			<script type="text/plain" class="language-cssgrammar no-whitespace-normalization">
				<attr-matcher> = [ '~' | '|' | '^' | '$' | '*' ]? '='
				<attribute-selector> = '[' <ident-token> <attr-matcher>
					[ <string-token> | <ident-token> ]? ']'
			</script>
		</div>
		<dl data-clone=".grammar.cheatsheet" data-show="[] | ?"></dl>

		<details class="notes">
			- The next step is parsing, which is the process of grouping tokens into constructs.
			- How this happens is defined in a compact form called a grammar.
			- [`&lt;any-value>`](https://drafts.csswg.org/css-syntax-3/#typedef-any-value)
			is a special token defined to allow any stream of tokens except open structures (unmatched parentheses, brackets, braces, broken strings, etc).
			- This is a simplified version. [Full selector grammmar](https://www.w3.org/TR/selectors/#grammar)
			- [Full declaration grammar](https://www.w3.org/TR/css-syntax-3/#grammar)
		</details>
	</article>

	<article class="slide language-cssgrammar tree-children md dont-resize tree-flushend progressive-subtree arrows" id="lookahead">
		- Start
			- `&lt;ident-token>`
				- `&lt;type-selector>`
			- `&lt;hash-token>`
				- `&lt;id-selector>`
			- `'.'`
				- `&lt;class-selector>`
			- `'['`
				- `&lt;attribute-selector>`
			- `':'`
				- `&lt;ident-token>`
					- `&lt;pseudo-class-selector>`
				- `':'`
					- `&lt;pseudo-element-selector>`


		<details class="notes">
			- Note that for most of these, we can tell what we have from the very first token.
			Only to distinguish pseudo-classes from pseudo-elements do we actually need two tokens, i.e. we need to "look ahead".
			- This is not a coincidence, it is by design.
			- Being able to determine the construct from the current token and by looking ahead at a fixed number of tokens
			is called "fixed lookahead" or LL(k) and is a very desirable property in parsers.
			- The CSS parser specifically is LL(1), i.e. needs to only look ahead at most one token.
		</details>
	</article>

	<article class="slide dont-resize" id="declaration-grammar">
		<header>
			<h1>CSS Grammars</h1>
			<p class="subtitle">Declaration (simplified)</p>

			<script type="text/plain" class="language-cssgrammar no-whitespace-normalization" data-production-indent="2">
				<declaration> = <ident-token> ':' <declaration-value> [ '!' <ident-token> ]? ';'
				<declaration-value> = [ <delim-token> | <whitespace-token>
					| <ident-token> | <hash-token>
					| <number-token> | <string-token>
					| <function-token> <any-value> ')'
					| <dimension-token> | <percentage-token> ]+
			</script>

			<dl data-clone=".grammar.cheatsheet" data-show="[] ?"></dl>

			<details class="notes">
				- [`&lt;declaration-value>`](https://drafts.csswg.org/css-syntax-3/#typedef-declaration-value)
			</details>
		</header>
	</article>

	<article class="slide dont-resize language-cssgrammar progressive-subtree" id="unbounded-lookahead">
		<h1>What could this be?</h1>

		<script type="text/plain" class="language-cssgrammar">
			<ident-token> <colon-token> <function-token> <ident-token> <comma-token>
			â®‘	<ident-token> <comma-token> <ident-token> <comma-token> <ident-token>
			â®‘	<comma-token> <ident-token> <comma-token> <ident-token> <)-token>
		</script>
		<div class="language-tokenizedcss delayed" style="align-self: stretch; margin-top: 2em">
			<pre><code class="delayed-children">article:is(h1, h2, h3, h4, h5, h6)</code></pre>
			<pre><code class="delayed-children">background:conic-gradient(red, yellow, lime, aqua, blue, magenta)</code></pre>
		</div>
		<details class="notes">
			- Take a look at this token stream here. Can you guess what CSS construct it represents?
			- Could it be a selector, like this one? Or maybe a declaration, like this one?
			- Letâ€™s try to tokenize them and find out!
		</details>
	</article>

	<article class="image slide" style="background: hsl(50 74% 92%)">
		<!-- https://sketchplanations.com/the-blind-and-the-elephant -->
		<img src="img/elephant-parable.png" alt="">
		<details class="notes">
			Without nesting we wouldnâ€™t even try both rules at once, we would know whether weâ€™re parsing a rule or a declaration in the first place, so there is no ambiguity.
			But with nesting, every time weâ€™re parsing the inside of a rule, we could have either.
			Would that make CSS ambiguous?
			Would it make it like the elephant in the well known parable who appeared to be different things to different blindfolded people depending on which part they touched?
		</details>
	</article>

	<article class="dont-resize slide" id="resolving-ambiguity">
		<h1>Resolving ambiguity</h1>
		<div class="language-tokenizedcss" style="align-self: stretch;">
			<pre><code>article:is(h1, h2, h3, h4, h5, h6) {</code></pre>
			<pre><code>background:conic-gradient(red, yellow, lime, aqua, blue, magenta);</code></pre>
		</div>
		<details class="notes">
			Nah, itâ€™s not as bad as that.
			Eventually, we would read an opening brace (for a selector) or a semicolon or closing brace (for a declaration) and we'd know what we have.
			But do note that we lost that very desirable fixed lookahead property:
			we now need to read a potentially unbounded number of tokens to know what we have.
			So when we started exploring the possibility of adding Nesting to CSS natively, this was a non starter.
			No browser would implement a CSS feature that would so fundamentally change CSS parsing.
			Remember, CSS needs to be blazing fast, and backtracking is slow.
		</details>
	</article>

	<article class="history slide" id="first-proposal">
		<h1>
			<time>2013</time>
			First nesting proposal
		</h1>
		<iframe data-src="tab-specs/v0/css-nesting/Overview.html" frameborder="0" class="browser"></iframe>
		<details class="notes">
			[Read a copy of the proposal](./tab-specs/v0/css-nesting/Overview.html)
		</details>
	</article>

	<article class="slide columns md">
		<h1>Syntax</h1>

		- `{ }` around nested rules
		- Optional `&`
		- No @-rule nesting

		```css
			table.browser-support {
				border-collapse: collapse;
				{
					th, td { border: 1px solid silver; }
					th { border: 0; }

					td {
						background: yellowgreen;
						{
							&:empty { background: red; }
							> a { color: inherit; }
						}
					}
				}
			}
		```
	</article>

	<article class="history slide">
		<h1>
			<time>June 2015</time>
			PostCSS implements
		</h1>
		<iframe data-src="https://github.com/csstools/postcss-nesting/tree/d63f6b6b1efef37c11d86a84de23fe901f74123a/#readme" class="browser"></iframe>
	</article>



	<article class="history slide columns" id="proposal2">
		<h1>
			<time>Sep 2015</time>
			New syntax
		</h1>
		<iframe data-src="tab-specs/v1/css-nesting/" class="browser"></iframe>
		<div class="md">
			- Dropped `{ }` around nested rules
			- Mandatory `&` or `@nest` prefix
			- Still no @-rule nesting
		</div>
		<details class="notes">
			[Read a copy of the proposal](./tab-specs/v1/css-nesting/)
		</details>
	</article>

	<article class="conversion slide columns md" style="--arrow-label: 'Became'">
		<h1>Changes</h1>

		```css
			.callout.info {
				color: var(--color-blue-dark);
				background: var(--color-blue-light);

				{
					.dark & {
						color: var(--color-blue-light);
						background: var(--color-blue-dark);
					}

					a { color: var(--color-blue); }
				}
			}
		```
		```css
			.callout.info {
				color: var(--color-blue-dark);
				background: var(--color-blue-light);

				@nest .dark & {
					color: var(--color-blue-light);
					background: var(--color-blue-dark);
				}

				& a { color: var(--color-blue); }
			}
		```
	</article>

	<article class="history slide">
		<h1>
			<time>Sep 2015</time>
			PostCSS updates
		</h1>
		<iframe data-src="https://github.com/csstools/postcss-nesting/tree/1931fbbd6a1e3ecf5aea1c73fed37307937544a3/#readme" class="browser"></iframe>
		<details class="notes">
			Interestingly, the plugin supported @-rule nesting, even though the spec did not.
		</details>
	</article>

	<article class="slide" style="background: url(img/84years.gif) center / cover" data-credits="Twentieth Century Fox / Giphy">
		<details class="notes">
			Well, not quite 84 but it sure felt like it.
			Part of the reason not much was happening was that a few people thought nesting was better served by a Houdini custom @-rule.
		</details>
	</article>

	<article class="dark slide">
		<img src="img/poll-2016.png" alt="" class="tweet">
	</article>

	<article class="history slide">
		<h1><time>Feb 2017</time> Ping #1</h1>
		<iframe data-src="https://github.com/w3c/csswg-drafts/issues/998" frameborder="0" class="browser"></iframe>
	</article>

	<article class="history slide">
		<h1><time>Mar 2018</time> Ping #2</h1>
		<iframe data-src="https://github.com/w3c/csswg-drafts/issues/2456" frameborder="0" class="browser"></iframe>
	</article>

	<article class="history slide">
		<h1><time>May 2018</time> Ping #3</h1>
		<iframe data-src="https://github.com/w3c/csswg-drafts/issues/2701" frameborder="0" class="browser"></iframe>
	</article>

	<article class="history slide">
		<h1><time>July 2018</time> CSS WG adopts spec</h1>
		<a href="https://github.com/w3c/csswg-drafts/issues/2701#issuecomment-402392212" class="browser" target="_blank"><img src="img/csswg-adopts.png" alt="" /></a>
	</article>

	<article class="dark slide" style="background: url(img/tumbleweed.gif) bottom / cover" data-credits="Giphy">
		<h1>Years passâ€¦</h1>
	</article>

	<article class="history slide">
		<h1>
			<time>2022</time>
			State of CSS Survey
		</h1>
		<iframe data-src="https://2022.stateofcss.com/en-US" frameborder="0" class="browser"></iframe>
	</article>

	<article class="dont-resize history slide" id="css-pain-points-2022">
		<time>Oct 2022</time>
		<img src="img/css-pain-points-2022.png" alt="">
	</article>

	<article class="dont-resize history slide columns">
		<h1>
			<time>Oct 2022</time>
			Chrome suddenly very keen to implement
		</h1>
		<a href="https://groups.google.com/a/chromium.org/g/blink-dev/c/-GxQ0MIcons/m/dTi5stNrBAAJ" class="browser" target="_blank"><img src="img/itp.png" alt=""></a>
	</article>

	<article class="history slide they-said">
		<time>Oct 2022</time>
		<div class="messages delayed-children">
			<blockquote>Lea, we cannot let this ship!</blockquote>
			<blockquote>This will be used all over stylesheets. Having to prefix every rule with `&` or `@nest` will be tedious to write, easy to forget, and noisy to read.</blockquote>
			<blockquote>And itâ€™s incompatible with `@scope`, so copying and pasting will require a ton of fixup.</blockquote>
			<blockquote>We must do something, ASAP!</blockquote>
			</blockquote>
		</div>
		<article class="person" id="elika">
			<img src="img/elika.jpg" alt="" class="person">
			<div>
				<h3>Elika Etemad</h3>
				<p>Extremely prolific CSS editor</p>
			</div>
		</article>
		<details class="notes">
			(In actuality we had a video call, and this is my recollection of the conversation)
		</details>
	</article>

	<article class="dont-resize slide history" id="breakouts">
		<h1>
			<time>Oct 2022</time>
			Further breakouts
		</h1>
		<div class="people">
			<article id="lea" class="person">
				<img src="img/lea.jpg" alt="">
				<div>
					<h3>Lea Verou</h3>
					<p>Thatâ€™s me!</p>
				</div>
			</article>
			<article data-clone="#elika"></article>
			<article id="tab" class="person">
				<img src="img/tab.jpg" alt="">
				<div>
					<h3>Tab Atkins-Bittner</h3>
					<p style="white-space: nowrap;">Extremely prolific CSS editor</p>
				</div>
			</article>
			<article id="mia" class="person">
				<img src="img/mia.avif" alt="">
				<div>
					<h3>Miriam Suzanne</h3>
					<p>Sass core contributor</p>
				</div>
			</article>

			<article id="jen" class="person">
				<img src="img/jen.jpg" alt="">
				<div>
					<h3>Jen Simmons</h3>
					<p>Developer Advocate @ Apple</p>
				</div>
			</article>
			<article id="brad" class="person">
				<img src="img/brad.jpg" alt="">
				<div>
					<h3>Brad Kemper</h3>
					<p>Web Designer/Developer</p>
				</div>
			</article>
		</div>
		<details class="notes">
			Shortly after, there were two seminal breakouts among these people, all seasoned CSS WG members and co-editors of several specs.
			We had general consensus that the syntax at the time needed improvement before it shipped in browsers,
			and several ideas about how to improve it.
		</details>
	</article>

	<article class="slide">
		<h1>We share with the WG</h1>
		<iframe data-src="https://github.com/w3c/csswg-drafts/issues/7834#issuecomment-1268957000" frameborder="0" class="browser"></iframe>
		<details class="notes">
			[Read summary](https://github.com/w3c/csswg-drafts/issues/7834#issuecomment-1268957000)
		</details>
	</article>

	<article class="slide">
		<h1>â€¦More discussionsâ€¦</h1>
	</article>

	<article class="slide" id="resolve-ambiguity">
		<h1>Strategies to resolve ambiguity</h1>

		<ol class="pop">
			<li>Per-rule prefix</li>
			<li>Nest rules in block</li>
			<li>Parser switch</li>
		</ol>
	</article>

	<article class="slide">
		<h1>Considerations</h1>

		<table>
			<thead>
				<th></th>
				<th></th>
			</thead>
		</table>
		<tr>
			<td>Compatibility with existing code</td>
			<td></td>
		</tr>
		<tr>
			<td>Compatibility with <code>@scope</code></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
		</tr>
		<tr>
			<td></td>
			<td></td>
		</tr>
	</article>

	<article class="slide columns" id="strategy-1">
		<header>
			<h1>
				<span class="pop">1</span> Per-rule prefix
			</h1>
			<p class="subtitle">
				Selectors of nested rules start with a disambiguating token
			</p>
		</header>

		<pre class="language-css"><code>
			ul {
				list-style: "ðŸ¦„";

				& li { margin: 0; }
				& a { color: inherit; }
				@nest nav & {
					list-style: none;
				}
			}
		</code></pre>
		<ul class="pros-cons delayed">
			<li class="pro">Backwards compat with postcss-nesting code</li>
			<li class="pro">Allows mixing rules and declarations</li>
			<li class="con">Easy to forget prefix</li>
			<li class="con">Tedious: O(N) extra syntax on the number of rules</li>
			<li class="con">Noisy to read</li>
			<li class="con">Incompatible with <code>@scope</code></li>
		</ul>
	</article>

	<article class="slide columns" id="strategy-2">
		<header>
			<h1>
				<span class="pop">2</span>
				Nest rules in block
			</h1>
			<p class="subtitle">
				Nested rules are wrapped in a block
			</p>
		</header>

		<pre class="language-css"><code>
			ul {
				list-style: "ðŸ¦„";

				{ /* Only rules in here */
					li { margin: 0; }
					a { color: inherit; }
					nav & {
						list-style: none;
					}
				}
			}
		</code></pre>
		<pre class="language-css"><code>
			ul {
				list-style: "ðŸ¦„";
			}
			{ /* Only rules in here */
				li { margin: 0; }
				a { color: inherit; }
				nav & {
					list-style: none;
				}
			}
		</code></pre>
		<div>
			<pre class="language-css"><code>
				ul {
					list-style: "ðŸ¦„";

					@nest { /* Only rules in here */
						li { margin: 0; }
						a { color: inherit; }
						nav & {
							list-style: none;
						}
					}
				}
			</code></pre>
			<ul class="pros-cons delayed">
				<li class="pro">Unrestricted selector syntax</li>
				<li class="pro">O(1) extra syntax on the number of rules</li>
				<li class="con">Extra indentation level</li>
				<li class="con">No mixing of declarations and rules</li>
			</ul>
		</div>
		<details class="notes">
			There were many more ideas about what the switch could be, even ASCII like `&&` or `@`,
			and each had its own pros and cons.
		</details>
	</article>

	<article class="slide columns" id="strategy-3">
		<header>
			<h1>
				<span class="pop">3</span>
				Parser switch
			</h1>
			<p class="subtitle">
				A specific token that signifies "only rules from now on"
			</p>
		</header>

		<pre class="language-css"><code>
			ul {
				list-style: "ðŸ¦„";

				@nest; /* Only rules below */

				li { margin: 0; }
				a { color: inherit; }
				nav & {
					list-style: none;
				}
			}
		</code></pre>
		<pre class="language-css"><code>
			ul {
				list-style: "ðŸ¦„";

				@media (width < 500px) {
					margin-left: 1ch;
				}
				li { margin: 0; }
				a { color: inherit; }
				nav & {
					list-style: none;
				}
			}
		</code></pre>
		<div>
			<pre class="language-css"><code>
				ul {
					list-style: "ðŸ¦„";

					& li { margin: 0; }
					a { color: inherit; }
					nav & {
						list-style: none;
					}
				}
			</code></pre>
			<ul class="pros-cons delayed">
				<li class="pro">O(1) extra syntax on the number of rules</li>
				<li class="con">Reordering code could break it</li>
				<li class="con">Nonobvious for some of these</li>
			</ul>
		</div>
		<details class="notes">
			In this strategy, as long as we encounter a non-declaration, we assume that everything after is a rule.
			This could be a token specifically for this, such as `@nest`, or any other known rule, including a no-op `@nest`.
		</details>
	</article>

	<article class="slide columns">
		<header>
			<h1>But what if the prefix occurred naturally?*</h1>
			<p class="subtitle">* in enough cases to make it worth it</p>
		</header>
		<a href="https://github.com/w3c/csswg-drafts/issues/7834#issuecomment-1272373216" target="_blank" class="browser"><img src="img/option-3.png" alt=""></a>
	</article>

	<article class="slide">
		<pre class="language-css"><code>
			ul {
				list-style: "ðŸ¦„";

				& li { margin: 0; }
				.foo {  }
				> a { color: inherit; }
				.dark & { }
				:is(nav) & {
					list-style: none;
				}
			}
		</code></pre>
	</article>
</section>

<section>
	<header class="slide">
		<h1>Could we go further?</h1>
	</header>
</section>

<section>
	<header class="slide">
		<h1>Takeaways</h1>
	</header>
</section>

<footer class="slide">
	<header>
		<h1>Thank you!</h1>
		<p class="subtitle">Slides at <a href="https://projects.verou.me/talks/css-nesting/">projects.verou.me/talks/css-nesting/</a>*</p>
		<p style="font-size: 60%;">
			* Yes, they use nesting, natively interperted by the browser.
		</p>
	</header>
	<dl class="cheatsheet" title="Reach out!">
		<dt class="bi bi-link-45deg"></dt>
		<dd>
			<a href="https://lea.verou.me">lea.verou.me</a>
		</dd>

		<dt class="bi bi-envelope-open"></dt>
		<dd>
			lea@verou.me
		</dd>

		<dt>
			<i class="bi bi-twitter"></i>
			<i class="bi bi-github"></i>
			<i class="bi bi-mastodon"></i>
			<i class="bi bi-linkedin"></i>
			<i class="bi bi-threads"></i>
		</dt>
		<dd>leaverou</dd>
	</dl>
</footer>

</body>
</html>